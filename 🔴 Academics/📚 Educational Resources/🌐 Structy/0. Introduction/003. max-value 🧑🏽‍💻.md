---
title: 003. max-value ğŸ‘¨ğŸ½â€ğŸ’»
created: 2023-08-04 01:58
updated: 2023-10-08 22:03
authors:
  - Edmund Leibert III
tags:
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-structy
  - ğŸ”´-academics/ğŸ“š-educational-resources/source-format/internet/website
  - ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-structy/ğŸ”–-bookmark/0-introduction/003-max-value-ğŸ§‘ğŸ½â€ğŸ’»
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-structy/ğŸ·ï¸-tag/challenge
  - study-note
cards-deck: ğŸ”´ Academics::ğŸ“š Educational Resources::ğŸŒ Structy::0. Introduction::003. max-value ğŸ§‘ğŸ½â€ğŸ’»
---

# ğŸŒ Structy

---

## ğŸ•¸ï¸ All Mention(s): 

---

## ğŸ”™ Previous Note(s):

---

## 0. Introduction

### 003. max-value ğŸ‘¨ğŸ½â€ğŸ’»

#### ğŸ§­ Approach

ï¹‡<br>
When iterating across a container to find some extreme value (e.g. maximum _or_ minimum), what initial value should we set for our `max_elem` (or `min_elem`)?

#card 

Should always (if the language, library, etc. allows) use $-\infty$ or $\infty$.

âŒ‚
<br>ï¹ˆ<br>^1694730801689




#### ğŸ“½ï¸ Walkthrough

##### C++

ï¹‡<br>
Does C++ support $-\infty$?

#card 

Yes! You can include the `<limits>` library and then call `numeric_limits<T>::infinity()`. Note that the `infinity()` member function of `std::numeric_limits` does _not_ support infinity for some types like `int`, `long long`, etc. 

Can use the member constant `has_infinity` to see if a type supports `infinity()` like soâ€¦

```cpp
#include <iostream>
#include <limits>
 
int main()
{
    std::cout << std::boolalpha
              << std::numeric_limits<int>::has_infinity << '\n'
              << std::numeric_limits<long>::has_infinity << '\n'
              << std::numeric_limits<float>::has_infinity << '\n'
              << std::numeric_limits<double>::has_infinity << '\n';
}
```

Possible output:

```
false
false
true
true
```

âŒ‚
<br>ï¹ˆ<br>^1694730801695


##### Python

##### JavaScript

##### Java

#### ğŸ’¡Solution

> [!Note]+ Why is this section empty?
> For notes regarding solution(s), attempt(s), etc., refer to section below that is a _universal_ template for notes of such concern.


#### Solution (C++)

ï¹‡<br>
What is theÂ _optimal_Â solution to this problem? If there are multiple, list them out and compare.

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

- **Approach #1**: Using the `max_element()` function
	1. Just use the `std::max_element()`!
	- **Computational Complexity**:
		- Time: $\mathcal{O}(n)$
		- Space: $\mathcal{O}(1)$

- **Approach #2**: Using pointers â­
	1. Create a variable called `maxValue` that will be initially set to the `numeric_limits<float>::max()`.
	2. Iterate across the container.
		1. If the current `maxValue` is less than the current value, set `maxValue` to that value.
	- **Asymptotic Analysis**:
		- Time: $\mathcal{O}(n)$
		- Space: $\mathcal{O}(1)$

- **Approach #3**:  Using the `max`
	1. Create a variable called `maxValue` that will be initially set to the `numeric_limits<float>::max()`.
	2. Iterate across the container.
		1. If the current `maxValue` is less than the current value, set `maxValue` to that value.
	- **Asymptotic Analysis**:
		- Time: $\mathcal{O}(n)$
		- Space: $\mathcal{O}(1)$

- **Official Structy Solution**:

	Code:
	
	```cpp
	#include <vector>
	#include <limits>
	
	float maxValue(std::vector<float> numbers) {
	  float max = -std::numeric_limits<float>::infinity();
	  for (float num : numbers) {
		if (num > max) {
		max = num;
		}
	  }
	  return max;
	}
	```

	- n = # numbers
	- Time: O(n)
	- Space: O(1)

âŒ‚
<br>ï¹ˆ<br>^1694722882728


##### Attempt #3 :: ğŸ“† 2023-09-14 12:09 -07:00 :: âœ… :: \[Author(s): Edmund Leibert III\]

###### Performance

- â²ï¸ **Time**: `0:01:00`
- ğŸ§”ğŸ½â€â™‚ï¸ **Author(s)**:
	- Edmund Leibert III

###### Notes

ï¹‡<br>
Is the following code valid?

```cpp
float maxValue(std::vector<float> numbers) {
    // todo
    int max_elem = numeric_limits<float>::lowest();

    for(auto elem : numbers) {
        max_elem = elem > max_elem ? elem : max_elem;
    }

    return max_elem;
}
```

#card 

This code is logically incorrect. The issue is related to the precision of floating point numbers. In your code, youâ€™re using an `int` variable `max_elem` to store the maximum value, which should be a `float`. This can cause precision issues when comparing and assigning floating point numbers. Hereâ€™s the corrected code:

```cpp
#include <vector>
#include <limits>

using namespace std;

float maxValue(vector<float> numbers) {
    float max_elem = numeric_limits<float>::lowest();

    for(auto elem : numbers) {
        max_elem = max(elem, max_elem);
    }

    return max_elem;
}
```

In this corrected code, `max_elem` is a `float`, which matches the type of the elements in your vector. The `max()` function from the `<algorithm>` header is used to find the maximum value, which can help avoid precision issues.

âŒ‚
<br>ï¹ˆ<br>^1694730801700


ï¹‡<br>
What _type_ does `max()` return? What _type_ does `max_element()` return?

#card 

- `ranges::max()`: This function compares two values and returns the maximum value. It does not return an iterator.
- `ranges::max_element()`: This function returns an iterator pointing to the maximum element in a range. If there are multiple maximum elements, it returns the first one. So, you need to dereference the iterator to get the actual value.

Hereâ€™s an example:

```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};

    // Using ranges::max()
    int a = 5;
    int b = 10;
    std::cout << "Max: " << std::ranges::max(a, b) << '\n';  // prints: Max: 10

    // Using ranges::max_element()
    auto it = std::ranges::max_element(v);
    std::cout << "Max Element: " << *it << '\n';  // prints: Max Element: 5

    return 0;
}
```

In this example, `ranges::max(a, b)` returns the maximum of `a` and `b`, which is `10`. `ranges::max_element(v)` returns an iterator pointing to the maximum element in the vector `v`, which is `5`. We dereference the iterator (`*it`) to get the actual value.

âŒ‚
<br>ï¹ˆ<br>^1694723693128



ï¹‡<br>
Why can you do `ranges::max(1,2)`, but for more than comparing two elements we need to use an initializer list? Can you just do `ranges::max(1,2,3,4)` without using the initializer list?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

[The `ranges::max()` function in C++20 is designed to compare two values and return the maximum](https://en.cppreference.com/w/cpp/algorithm/ranges/max)[1](https://en.cppreference.com/w/cpp/algorithm/ranges/max). If you want to find the maximum of more than two values, you need to use an initializer list, as inâ€¦
```cpp
ranges::max({1, 2, 3, 4})
```
<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max)</sup>.

This is because C++ functions canâ€™t natively take a variable number of arguments of any type. [There are ways to achieve this using templates and variadic arguments, but these are more complex and not used in the standard library functions](https://stackoverflow.com/questions/1657883/variable-number-of-arguments-in-c)<sup>[\[2\]](https://stackoverflow.com/questions/1657883/variable-number-of-arguments-in-c)</sup>.

So, while it might seem more intuitive to write `ranges::max(1, 2, 3, 4)`, this isnâ€™t supported in C++. [You need to use an initializer list or another container that holds all the values you want to compare](about:blank#)<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max)</sup>.

âŒ‚
<br>ï¹ˆ<br>^1694722903499


ï¹‡<br>
Can `ranges::max()` take multiple arguments?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

Yes, the `ranges::max()` function in C++20 can take multiple arguments. [It compares all the arguments and returns the maximum value](https://en.cppreference.com/w/cpp/algorithm/ranges/max)<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max)</sup>. Hereâ€™s an example:

```cpp
#include <iostream>
#include <ranges>

int main() {
    std::cout << "Max: " << std::ranges::max({1, 2, 3, 4, 5}) << '\n';  // prints: Max: 5
    return 0;
}
```

In this exampleâ€¦

```cpp
ranges::max({1, 2, 3, 4, 5})
``` 

returns the maximum value in the initializer list `{1, 2, 3, 4, 5}`, which is `5`<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max)</sup>.

Remember that this function is part of C++20, so youâ€™ll need a compiler that supports C++20 to use it.

âŒ‚
<br>ï¹ˆ<br>^1694722831579



ï¹‡<br>
What is the difference between `ranges::max()` and` ranges::max_element()`?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

[The `ranges::max()` and `ranges::max_element()` functions in C++20 are used to find the maximum value in a range, but they do so in slightly different ways](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)</sup>:

- `ranges::max(a, b)`: This function compares two values and returns the maximum. [If more than two values are given, it returns the maximum value among all the arguments](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)</sup>.
	- Hereâ€™s an example of using `ranges::max()`:
		```cpp
		#include <iostream>
		#include <ranges>
		
		int main() {
		    int a = 5;
		    int b = 10;
		    std::cout << "Max: " << std::ranges::max(a, b) << '\n';  // prints: Max: 10
		    return 0;
		}
		```
	- In this example, `ranges::max(a, b)` returns the maximum of `a` and `b`, which is `10`.

- `ranges::max_element(first, last)`: This function returns an iterator pointing to the maximum element in the range `[first, last)`. [If there are multiple maximum elements, it returns the first one](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)</sup>.
	- And hereâ€™s an example of using `ranges::max_element()`:
		```cpp
		#include <iostream>
		#include <vector>
		#include <ranges>
		
		int main() {
			std::vector<int> v = {1, 2, 3, 4, 5};
			auto it = std::ranges::max_element(v);
			std::cout << "Max Element: " << *it << '\n';  // prints: Max Element: 5
			return 0;
		}
		```
	- In this example, `ranges::max_element(v)` returns an iterator pointing to the maximum element in the vector `v`, which is `5`. We dereference the iterator (`*it`) to get the actual value.

So, if you want to find the maximum value among a few specific values, you can use `ranges::max()`. If you want to find the maximum element in a range of elements (like an array or a vector), you can use `ranges::max_element()`. [Remember that `ranges::max_element()` returns an iterator, so you need to dereference it to get the actual value](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)<sup>[\[1\]](https://en.cppreference.com/w/cpp/algorithm/ranges/max_element)</sup>.

Remember that this function is part of C++20, so youâ€™ll need a compiler that supports C++20 to use it.

âŒ‚
<br>ï¹ˆ<br>^1694722831583


ï¹‡<br>
If I wish to use `ranges` in C++, what must I _always_ make sure to include first?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

First, to use the `ranges` library in C++, you must be using C++20 or later. The `ranges` library is a part of the Standard Library that was added in C++20. It provides facilities for dealing with ranges of values. A range is an object that refers to a sequence of elements, such as an array, a list, or an I/O stream.

To use the `ranges` library, you need to include the `<ranges>` header in your code:

```cpp
#include <ranges>
```

Please make sure your compiler supports C++20 to use this feature. If it doesnâ€™t, you might need to update your compiler or use a different one that does support C++20.

âŒ‚
<br>ï¹ˆ<br>^1694722831587


##### Attempt #2 :: ğŸ“† 2023-09-13 17:09 -07:00 :: âœ… :: \[Author(s): Edmund Leibert III\]

###### Performance

- â²ï¸ **Time**: `0:04:15`
- ğŸ§”ğŸ½â€â™‚ï¸ **Author(s)**:
	- Edmund Leibert III

###### Notes


As detailed in [cppreference](https://en.cppreference.com/), {1:`std::numeric_limits<T>::lowest`} returns the {2:lowest finite value representable by the numeric typeÂ `T`}, that is, a {2:finite valueÂ `x`Â such that there is no other finite valueÂ `y`Â where `yÂ <Â x`}. This is different fromÂ `std::numeric_limits<T>::min()`Â for floating-point types. Only meaningful for bounded types.
^1694722831591

ï¹‡<br>
What library is the `std::numeric_limits<T>` a part of?

*Note that T stands for template

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

Is defined in the `<limits>` header.

âŒ‚
<br>ï¹ˆ<br>^1694722831595


ï¹‡<br>
What is the return value of `std::numeric_limits<bool>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

`false`

âŒ‚
<br>ï¹ˆ<br>^1694722831599



ï¹‡<br>
What is the return value of `std::numeric_limits<char>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 
â€‹
`0â€‹`

âŒ‚
<br>ï¹ˆ<br>^1694722831602



ï¹‡<br>
What is the return value of `std::numeric_limits<signed char>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

â€‹`0`â€‹

âŒ‚
<br>ï¹ˆ<br>^1694722831606



ï¹‡<br>
What is the return value of `std::numeric_limits<unsigned char>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

â€‹`0â€‹`

âŒ‚
<br>ï¹ˆ<br>^1694722831610



ï¹‡<br>
What is the return value of `std::numeric_limits<wchar_t>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

â€‹`0â€‹`

âŒ‚
<br>ï¹ˆ<br>^1694722831614



ï¹‡<br>
What is the return value of `std::numeric_limits<short>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

â€‹`0â€‹`

âŒ‚
<br>ï¹ˆ<br>^1694722831618



ï¹‡<br>
What is the return value of `std::numeric_limits<unsigned short>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

â€‹`0â€‹`

âŒ‚
<br>ï¹ˆ<br>^1694722831623



ï¹‡<br>
What is the return value of `std::numeric_limits<int>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

â€‹`0â€‹`

âŒ‚
<br>ï¹ˆ<br>^1694722831627



ï¹‡<br>
What is the return value of `std::numeric_limits<unsigned int>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

â€‹`0`â€‹

âŒ‚
<br>ï¹ˆ<br>^1694722831632



ï¹‡<br>
What is the return value of `std::numeric_limits<long>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

â€‹`0â€‹`

âŒ‚
<br>ï¹ˆ<br>^1694722831636



ï¹‡<br>
What is the return value of `std::numeric_limits<unsigned long>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

â€‹`0â€‹`

âŒ‚
<br>ï¹ˆ<br>^1694722831639



ï¹‡<br>
What is the return value of `std::numeric_limits<long long>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

â€‹`0`â€‹

âŒ‚
<br>ï¹ˆ<br>^1694722831643



ï¹‡<br>
What is the return value of `std::numeric_limits<unsigned long long>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

â€‹`0â€‹`

âŒ‚
<br>ï¹ˆ<br>^1694722831648



ï¹‡<br>
What is the return value of `std::numeric_limits<float>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

`HUGE_VALF`

âŒ‚
<br>ï¹ˆ<br>^1694722831652



ï¹‡<br>
What is the return value of `std::numeric_limits<double>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

`HUGE_VAL`

âŒ‚
<br>ï¹ˆ<br>^1694722831656



ï¹‡<br>
What is the return value of `std::numeric_limits<long double>::infinity()` in C++?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

`HUGE_VALL`

âŒ‚
<br>ï¹ˆ<br>^1694722831661




##### Attempt #1 :: ğŸ“† 2023-22-07 10:00 -07:00 :: âœ… :: \[Author(s): Edmund Leibert III\]

###### Performance

- â²ï¸ **Time**: `0:05:00`
- ğŸ§”ğŸ½â€â™‚ï¸ **Author(s)**:
	-  Edmund Leibert III

###### Notes

ï¹‡<br>
In C++, how can you represent negative or positive infinity?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

- One can use the <span class="spoiler">`limits`</span> library, which is part of the C++ Standard library.
- With that, you can use the function `numeric_limits<int>::infinity()` to call postive infinity of the type `int`. 
- If you wanted to negative infinity, you can simply do `-numeric_limits<int>::infinity()` to call negative infinity of the type `int`. 

âŒ‚
<br>ï¹ˆ<br>^1694722831665




ï¹‡<br>
What is the downside of using `numeric_limits<int>::infinity()` than just using `numeric_limits<int>::double()`?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

- `std::numeric_limits<int>::infinity()` return the representation of positive, **if available**. 
- However, `std::numeric_limits<int>::has_inifinity` returns `false` for `int`, meaning that `std::numeric_limits<int>::infinity()` does not return any meaningful value to compare with.

âŒ‚
<br>ï¹ˆ<br>^1694722831669




ï¹‡<br>
How can I check the if a data type supports infinity?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

Use the `std::numeric_limits<int>::has_inifinity` to check if the value returned from that expression is `true` or `false`.

âŒ‚
<br>ï¹ˆ<br>^1694722831673




ï¹‡<br>
When trying to assign the value *negative* infinity (of type `int`) via the `<limits>` library, where should one place the negative sign?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

`-numeric_limits<int>::infinity()` Note that the negative sign is placed *before* the whole expression.

âŒ‚
<br>ï¹ˆ<br>^1694722831678




ï¹‡<br>
What does the `::` mean in the expression `numeric_limits<int>::infinity()`?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

- In C++ programming language, theÂ `::`Â is called theÂ **scope resolution operator**. 
- It is used to specify the scope of a function or variable. 
	- In this case,Â `numeric_limits<int>::infinity()`Â means that theÂ `infinity()`Â function is being called from theÂ `numeric_limits`Â class template specialized for theÂ `int`Â type. 

âŒ‚
<br>ï¹ˆ<br>^1694722831682




ï¹‡<br>
What does `numeric_limits<int>::lowest()` return when the data type is of `int`?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

- Returns the lowest  possible (negative) value of `int`
- Same as `numeric_limits<int>::min()`

âŒ‚
<br>ï¹ˆ<br>^1694722831687




ï¹‡<br>
What does `numeric_limits<int>::min()` return when the data type is of `int`?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

- Returns the lowest  possible (negative) value of `int`
- Same as `numeric_limits<int>::lowest()`

âŒ‚
<br>ï¹ˆ<br>^1694722831692




ï¹‡<br>
What does `numerc_limits<int>::min()` return when the data type is of a floating-point type (i.e., `double`, `float`)?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

- Return the minimum positive normalized value.
- Note, how this is different from when the data type is `int`.

âŒ‚
<br>ï¹ˆ<br>^1694722831697




ï¹‡<br>
What does `numerc_limits<int>::min()` return when the data type is of a floating-point type? 

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

- Return the lowest value (which can be negative) of the type.

âŒ‚
<br>ï¹ˆ<br>^1694722831702




ï¹‡<br>
What can `double` and `float` be classified as? 

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

 They can be classified as **floating point** data points.

âŒ‚
<br>ï¹ˆ<br>^1694722831706




ï¹‡<br>
In C++, what is the difference between iterator based loops vs range-`for` loop? 

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

- First and foremost, use range-`for` loops.
- A range-`for` loop uses iterators internally. The loop variable is the *dereferenced value*, not the iterator itself.

âŒ‚
<br>ï¹ˆ<br>^1694722831710




ï¹‡<br>
In C++, does a range-`for` loop expose access to its internal iterators?  

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

A range-`for` loop does *not* expose access to its internal iterators.

âŒ‚
<br>ï¹ˆ<br>^1694722831714




ï¹‡<br>
What are **containers** in C++?  

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

- In C++, containers are data structures that store and organize a collection of objects in memory.
- They are parts of the C++ Standard Library and provide a convenient way to manage collections of data, offering different trade-offs in terms ofâ€¦
	- performance
	- memory usage
	- functionality

âŒ‚
<br>ï¹ˆ<br>^1694722831717





ï¹‡<br>
What are the main categories of containers in C++? 

#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

The main categories of <span class="spoiler">containers</span>â€¦
- Sequence containers
- Associative containers
- Unordered associative containers
- Container adapters

âŒ‚
<br>ï¹ˆ<br>^1694722831721




ï¹‡<br>
What type of container is `queue`?  

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

container adaptor

âŒ‚
<br>ï¹ˆ<br>^1694722831725




ï¹‡<br>
What type of container is `stack`?  

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

container adaptor

âŒ‚
<br>ï¹ˆ<br>^1694722831728




ï¹‡<br>
What are sequence containers?  

#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

- Store elements in a linear sequence, where each element has a specific position.
- Examples includeâ€¦
	- <span class="spoiler">`std::vector`</span>: <span class="spoiler">A dynamic array that automatically resizes itself whenits capacity is exceeded. It provides fast random access and efficient insertions/deletion at the end, but inertions/deletions in the middle can be slow.</span> 
	- <span class="spoiler">`std::list`</span>: <span class="spoiler">A doubly-linked list that allows for fast insertinos and deletions at any position, but does not support random access.</span>
	- <span class="spoiler">`std::deque`:</span> <span class="spoiler">A double-ended queue that supports fast random access and efficient insertions/deletions at both the beginning and the end.</span>
	- <span class="spoiler">`std::forward_list` (sinceC++11)</span>: <span class="spoiler">A singly-linked list that allows for fast insertions and deletions at any position, but does not support random access or bidirectional traversal.</span>
	- <span class="spoiler">`std::array` (sineC++11)</span>: <span class="spoiler">A fixed-size array with a compile-time size, providing fast random access and a small memory footprint.</span>

âŒ‚
<br>ï¹ˆ<br>^1694722831732





ï¹‡<br>
What are associative and unordered associative containers?

#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

- These containers store elements in a sorted or hashed manner, which allows for faster access, insertion, and deletion based on specific keys.
- Examples includeâ€¦
	- <span class="spoiler">`std::set`</span>: <span class="spoiler">A sorted collection of unique elements, typically implemented as a balanced binary search tree.</span>
	- <span class="spoiler">`std::multiset`</span>: <span class="spoiler">Similar to `std::set`, but allows multiple instances of the same element.</span>
	- <span class="spoiler">`std::map`</span>: <span class="spoiler">A sorted collection of key-value pairs, with unique keys, typically implemented as a balanced binary search tree.</span>
	- <span class="spoiler">`std::multimap`</span>: <span class="spoiler">Similar to `std::map`, but allows multiple key-value pairs with the same key.</span>
	- <span class="spoiler">`std::unordered_set` (sinceC++11)</span>: <span class="spoiler">A hashed collection of unique elements, providing average constant-time access, insertion, and deletion.</span>
	- <span class="spoiler">`std::unordered_multiset` (sinceC++11)</span>: <span class="spoiler">Similar to `std::unordered_set`, but allows multiple instances of the same element.</span>
	- <span class="spoiler">`std::unordered_map` (sinceC++11)</span>: <span class="spoiler">A hashed collection of key-value pairs, with unique keys, providing average constant-time access, insertion, and deletion.</span>
	- <span class="spoiler">`std::unordered_multimap` (sinceC++11)</span>: <span class="spoiler">Similar to `std::unordered_map`, but allows multiple key-value pairs with the same key.</span>

âŒ‚
<br>ï¹ˆ<br>^1694722831736





ï¹‡<br>
What are some key benefits of containers in C++?

#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

- These containers provide various iterator types that allow you to traverse and manipulate the elements in a uniform manner.
- Additionally, they are designed to worth withC++ standard library algorithms, which makes it easy to perform common operations such asâ€¦
	- <span class="spoiler">searching elements</span>
	- <span class="spoiler">sorting elements</span>
	- <span class="spoiler">transforming elements</span>

âŒ‚
<br>ï¹ˆ<br>^1694722831744





ï¹‡<br>
In C++, what is an input iterator?

#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- A type of iterator that allows you to traverse a container in a read-only, forward direction.
	- It is the most basic iterator category in theC++ Standard Library
	- Provides the minimum functionality required for single-pass algorithms, like reading elements from an input stream, or iterating through elements of a container in a linear fashion.

âŒ‚
<br>ï¹ˆ<br>^1694722831754





ï¹‡<br>
What requirements must an iterator satisfy?

#card-reverse #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

 *Donâ€™t worry about this too much*
1. <span class="spoiler">Copy-constructible:</span>
2. <span class="spoiler">Copy-assignable:</span>
3. <span class="spoiler">Destructible:</span>
4. <span class="spoiler">Equality-comparable:</span>
5. <span class="spoiler">Incrementable/Decrementable:</span>

âŒ‚
<br>ï¹ˆ<br>^1694722831761





ï¹‡<br>
What operations does an input iterator satisfy?

#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

1. <span class="spoiler">Dereference (`*`):</span> <span class="spoiler">Access the value pointed to by the iterator (read-only</span>
2. <span class="spoiler">Increment (`++`):</span> <span class="spoiler">Move the iterator to the next element in the container.</span>
3. <span class="spoiler">Equality comparison (`==`):</span> <span class="spoiler">Check if two iterators are equal (point to the same element).</span>
4. <span class="spoiler">Inequality comparison (`!=`):</span> <span class="spoiler">Check if two iterators are not equal (point to different elements).</span>

âŒ‚
<br>ï¹ˆ<br>^1694722831767




ï¹‡<br>
First and foremost, what exactly is an `input_iterator`?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

- To provide more context, an input iterator is a type of iterator that is part of a collection/new way of organizing iterators called â€œ[Iterator concepts](https://en.cppreference.com/w/cpp/iterator).â€
	- While, I am still unsure about what the difference is between an `input_iterator` and a `output_iterator`, we need not concern ourselves for now.

âŒ‚
<br>ï¹ˆ<br>^1694722831773




ï¹‡<br>
What type of iterator is returned when calling the method `.begin()` of a `forward_list`?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

It returns a `forward_iterator`

âŒ‚
<br>ï¹ˆ<br>^1694722831777




ï¹‡<br>

What type of iterator can only be incremented (i.e., can not be decremented)?

#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

`forward_iterator`s 

Refer to the this for more information: [C++ named requirements: LegacyInputIterator - cppreference.com](https://en.cppreference.com/w/cpp/named_req/InputIterator)

âŒ‚
<br>ï¹ˆ<br>^1694722831781




ï¹‡<br>
What are some containers that return forward iterators?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- `std::istream_iterator` for reading from input streams
- iterator types used by `std::forward_list`

âŒ‚
<br>ï¹ˆ<br>^1694722831785




ï¹‡<br>
What are three types of forms of ranged-based `for` loops using the keyword `auto`?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

```cpp
// The auto keyword causes type inference to be used. Preferred. 
for( auto y : x ) { // Copy of 'x', almost always undesirable 
	cout << y << " ";
} 
cout << endl;
for( auto &y : x ) { // Type inference by reference.
	// Observes and/or modifies in-place. Preferred when modify is needed. 
	cout << y << " ";
} 
cout << endl; 
for( const auto &y : x ) { // Type inference by const reference.
	// Observes in-place. Preferred when no modify is needed.
	cout << y << " ";
}
```

âŒ‚
<br>ï¹ˆ<br>^1694722831789




ï¹‡<br>
What is the difference between `std::numeric_limits<float>::infinity()` and `std::numeric_limits<float>::lowest()`?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

- One returns just the lowest *finite* value while the other returns a special value marked as â€œpositive infinity.â€
- Refer below to see what the console outputs when calling the commandâ€¦
```bash
-3.40282e+38
inf
```

âŒ‚
<br>ï¹ˆ<br>^1694722831792




ï¹‡<br>
What was my initial approach?

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

**Computational Complexity**:
<span class="spoiler">Time: $O(n)$</span>
<span class="spoiler">Space: $O(1)$</span>
1. <span class="spoiler">Create a variable `maxNum` that is negative infinity
	- Note that this is our â€œbase caseâ€, all values in our list must be equal or greater.</span>
2. <span class="spoiler">Iterate across all the elements in the container linearly
	- If `maxNum` is less than some element, maxNum is equal to that element.</span>
3. <span class="spoiler">Finish iterating and return `maxNum`</span>

âŒ‚
<br>ï¹ˆ<br>^1694722831796




#### Solution (Python)


#### Solution (JavaScript)



---

## ğŸ”œ Next Note(s):
- [[ğŸ”´ Academics/ğŸ“š Educational Resources/ğŸŒ Structy/0. Introduction/004. is prime ğŸ‘¨ğŸ½â€ğŸ’»|004. is prime ğŸ‘¨ğŸ½â€ğŸ’»]]

---
