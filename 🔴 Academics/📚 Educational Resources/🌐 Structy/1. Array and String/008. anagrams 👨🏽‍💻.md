---
title: 008. anagramsÂ ğŸ‘¨ğŸ½â€ğŸ’»
created: 2023-08-18 05:48
updated: 2023-09-30 16:21
authors:
  - Edmund Leibert III
tags:
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-structy
  - ğŸ”´-academics/ğŸ“š-educational-resources/source-format/internet/website
  - ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-structy/ğŸ”–-bookmark/1-array-and-string/008-anagrams-ğŸ§‘ğŸ½â€ğŸ’»
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-structy/ğŸ·ï¸-tag/challenge
  - study-note
cards-deck: ğŸ”´ Academics::ğŸ“š Educational Resources::ğŸŒ Structy::1. Array and String::008. anagrams ğŸ§‘ğŸ½â€ğŸ’»
---

#  ğŸŒ Structy

---

## ğŸ•¸ï¸ All Mention(s): 

---

## ğŸ”™ Previous Note(s):

---

## 1. Array and String

### **008. anagrams ğŸ‘¨ğŸ½â€ğŸ’»**

#### ğŸ§­ Approach

#### ğŸ“½ï¸ Walkthrough

##### C++

##### Python

##### JavaScript

##### Java

#### ğŸ’¡Solution

> [!Note]+ Why is this section empty?
> For notes regarding solution(s), attempt(s), etc., refer to section below that is a _universal_ template for notes of such concern.


#### Solution (C++)

ï¹‡<br>
What is theÂ _optimal_Â solution to this problem? If there are multiple, list them out and compare.

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

- **Approach #1: Using only _one_ map**
	```cpp
	bool anagrams(std::string s1, std::string s2) {
	    unordered_map<char, int> s1map;
	    for (auto s1_char: s1) {
	        s1map[s1_char] = (s1map.find(s1_char) == s1map.end()) ? 1 : s1map[s1_char] + 1;
	    }
	    for (auto s2_char: s2) {
	        if (s1map.find(s2_char) != s1map.end()) {
	            s1map[s2_char] = s1map[s2_char] - 1;
	        } else {
	            return false;
	        }
	    }
	    for (auto s1_char: s1) {
	        if (s1map[s1_char] == 0) {
	        } else {
	            return false;
	        }
	    }
	    // todo
	    return true;
	}
	```
- The given program checks if two strings are anagrams by counting the frequency of each character in the first string and then decrementing the count for each character in the second string. If all counts are zero, the strings are anagrams.
	- The **time complexity** of this program is **O(n)**, where **n** is the length of the strings. This is because each character in both strings is visited once.
	- The **space complexity** of this program is **O(1)**. Although a hash map is used, the number of keys in the map is bounded by the size of the alphabet. In case of ASCII characters, there are 128 possible characters, and in case of extended ASCII, there are 256 possible characters. Therefore, the space complexity is constant as it does not change with the size of the input string.

- **Official Structy Solution**
	```cpp
	bool anagrams(std::string s1, std::string s2) {  
	    unordered_map<char, int> s1map;  
	    for (auto s1_char: s1) {  
	        s1map[s1_char] = (s1map.find(s1_char) == s1map.end()) ? 1 : s1map[s1_char] + 1;  
	    }  
	    for (auto s2_char: s2) {  
	        if (s1map.find(s2_char) != s1map.end()) {  
	            s1map[s2_char] = s1map[s2_char] - 1;  
	        } else {  
	            return false;  
	        }  
	    }  
	    for (auto s1_char: s1) {  
	        if (s1map[s1_char] == 0) {  
	        } else {  
	            return false;  
	        }  
	    }  
	    // todo  
	    return true;  
	}
	```
	- n = length of string 1
	- m = length of string 2
	- Time: O(n + m)
	- Space: O(n + m)

âŒ‚
<br>ï¹ˆ<br>^1694821545754


##### Attempt #3 :: ğŸ“† 2023-09-15 13:43 -07:00 :: âŒ :: \[Author(s): Edmund Leibert III\]

###### Performance

- â²ï¸ **Time**: `0:21:18`
- ğŸ§”ğŸ½â€â™‚ï¸ **Author(s)**:
	- Edmund Leibert III

###### Notes

ï¹‡<br>
What is the space complexity of using a hash map when the input is only alphabetical `char`s?

#card 

In such cases, we can state that the space complexity to be $\mathcal{O}(1)$. Although a hash map is used, the number of keys in the map is bounded by the size of the alphabet. In case of ASCII characters, there are 128 possible characters, and in case of extended ASCII, there are 256 possible characters. Therefore, the space complexity is constant as it does not change with the size of the input string.

âŒ‚
<br>ï¹ˆ<br>^1694822433469



ï¹‡<br>
Is the following code valid?

```cpp
bool anagrams(std::string s1, std::string s2) {  
    unordered_map<char,int> s1map;  
  
    for(auto s1_char : s1) {  
        s1map[s1_char] = (s1map.find(s1_char) == s1map.end()) ? 1 : s1map[s1_char] + 1;  
    }  
  
    for(auto s2_char : s2) {  
        if(s1map.find(s2_char) != s1map.end()) {  
            s1map[s2_char] = s1map[s2_char] - 1;  
        }  
        else {  
            return false;  
        }  
    }  
  
    for(auto s2_char : s2) {  
        if(s1map[s2_char] == 0) {  
            return true;  
        }  
        else {  
            return false;  
        }  
    }  
  
    // todo  
    return true;  
}
```

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

While the code will compile, it is _not_ logically correct. The snippet belowâ€¦

```cpp
if(s1map[s2_char] == 0) {  
	return true;  
}  
```

â€¦will just immediately return `true` when it should just `continue`.

âŒ‚
<br>ï¹ˆ<br>^1694821545761



##### Attempt #2 :: ğŸ“† 2023-07-31 12:21 -07:00 :: âŒ :: \[Author(s): Edmund Leibert III\]

###### Performance

- â²ï¸ **Time**: `0:05:07`
- ğŸ§”ğŸ½â€â™‚ï¸ **Author(s)**:
	- Edmund Leibert III

###### Notes

ï¹‡<br>
First and foremost, must anagrams have the same number of occurrences? 

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

Yes!!!

âŒ‚
<br>ï¹ˆ<br>^1694821545768



ï¹‡<br>
What is the definition of an anagram? 

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

Containers that have the same elements and the same number of occurrences of those elements. 

âŒ‚
<br>ï¹ˆ<br>^1694821545774



ï¹‡<br>
Is the following code valid? 

```cpp
map2[*it2] = map2[*it2]++;
```

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

Yes, but now how you intend it to be.  In the above case, you are essentially calling the post increment, so essentially you are just having `map2[*it2]` be incremented, but then having it be assigned to its previously self so it is essentially overwriting the increment. If you wish to increment an element in a container, just do the followingâ€¦

```cpp
map2[*it2]++;
```

âŒ‚
<br>ï¹ˆ<br>^1694821545779



##### Attempt #1 :: ğŸ“† 2023-07-22 10:21 -07:00 :: âŒ :: \[Author(s): Edmund Leibert III\]

###### Performance

- â²ï¸ **Time**: `0:24:43`
- ğŸ§”ğŸ½â€â™‚ï¸ **Author(s)**:
	- Edmund Leibert III

###### Notes

ï¹‡<br>
When an element, that does not previously exist in a `std::map` or `std::unordered_map` container, is inserted, what value does the expression return? 

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

```cpp
s1Map[ *(it1 + i) ] = s1Map[ *(it1 + i) ] + 1;
```

The expression, on the right side, `s1Map[ *(it1 + i) ]`, returns 0 if `*(it + i)` did not previously exist in the container.

âŒ‚
<br>ï¹ˆ<br>^1694821545784



ï¹‡<br>
What library is `std::unordered_map` from? 

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

It is from the library `<unordered_map>`. 

âŒ‚
<br>ï¹ˆ<br>^1694821545790



ï¹‡<br>
Is `std::ordered_map` from the library `<unordered_map>`? 

#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp

No, it is from the library `<ordered_map>`. 

âŒ‚
<br>ï¹ˆ<br>^1694821545796




#### Solution (Python)

#### Solution (JavaScript)


---

## ğŸ”œ Next Note(s):
- [[ğŸ”´ Academics/ğŸ“š Educational Resources/ğŸŒ Structy/1. Array and String/009. most frequent char ğŸ‘¨ğŸ½â€ğŸ’»|009. most frequent char ğŸ‘¨ğŸ½â€ğŸ’»]]

---
