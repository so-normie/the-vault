---
title: 1. Two Sum
created: 2023-09-03 20:31
updated: 2023-09-07 19:43
authors:
  - Edmund Leibert III
tags:
  - üî¥-academics/üìö-educational-resources/name/leetcode
  - üî¥-academics/üìö-educational-resources/source-format/internet/website
  - üî¥-academics/üìö-educational-resources/name/üåê-leetcode/üîñ-bookmark/üåê-leetcode/problems/1-two-sum
  - üî¥-academics/üìö-educational-resources/name/üåê-leetcode/üè∑Ô∏è-tag/problem/tag/topic/hash-table
  - üî¥-academics/üìö-educational-resources/name/üåê-leetcode/üè∑Ô∏è-tag/problem/tag/topic/array
  - study-note
cards-deck: üî¥ Academics::üìö Educational Resources::üåê LeetCode::Problems::1. Two Sum
---

#  üåê LeetCode

---

## üï∏Ô∏è All Mention(s): 

---

## üîô Previous Note(s):

---

##  Problems

### 1. Two Sum

> [!info]+ Where can the problem be found?
> The problem can be found here: [1. Two Sum](https://leetcode.com/problems/two-sum/)

#### Solution (C++)

Ôπá<br>
What is the _optimal_ solution to this problem? If there are multiple, list them out and compare.

#card 

**Approach #3**: One-pass Hash Table ‚úÖüåü

```cpp
// target = a + b
// a = target - b
#include <unordered_map>
#include <vector>

using namespace std;

class Solution {

public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> numMap; // value, index

        for(int i {0}; i < nums.size(); i++) {
            int complement = target - nums[i];
            if(numMap.find(complement) == numMap.end()) {
                numMap[nums[i]] = i;
            }
            else { // We have a found the complemet
                return {i, numMap[complement]};
            }
        }

        return {};
    }
};
```

- **Asymptotic Complexity**:
	- Time: $\mathcal{O}(n)$
	- Space: $\mathcal{O}(n)$

‚åÇ
<br>Ôπà<br>^1693800407396


##### Attempt #1 :: üìÜ 2023-09-03 20:31 :: ‚úÖ :: \[Author(s): Edmund Leibert III\]

###### Performance

- ‚è≤**Time**: `0:06:02`
- üßîüèΩ‚Äç‚ôÇÔ∏è **Author(s)**: 
	- `Edmund Leibert III`

###### Notes

Ôπá<br>
What is the average time complexity for insertion, deletion, and lookup in a C++ `std::map`?

#card

Logarithmic in the size of the container.

‚åÇ
<br>Ôπà<br>^1693800407413


Ôπá<br>
What is the data structure typically used to implement a C++ `std::map`?

#card

Balanced Binary Search Tree (e.g., Red-Black Tree)

‚åÇ
<br>Ôπà<br>^1693800407419


Ôπá<br>
What is the average time complexity for insertion, deletion, and lookup in a C++ `std::unordered_map`?

#card

Constant on average, worst case linear in the size of the container.

‚åÇ
<br>Ôπà<br>^1693800407425


Ôπá<br>
What is the data structure typically used to implement a C++ `std::unordered_map`?

#card

Hash Table

‚åÇ
<br>Ôπà<br>^1693800407430


Ôπá<br>
Under what conditions can the time complexity for operations in a `std::unordered_map` become linear $\mathcal{O}(n)$?

#card

When there are hash collisions that require traversing a linked list or another hash table at a particular slot.

‚åÇ
<br>Ôπà<br>^1693800407436


Ôπá<br>
When is it generally beneficial to use `std::unordered_map` over `std::map` in C++?

#card

When optimizing for speed and you have a good hash function that minimizes the likelihood of collisions, making the average case time complexity of $\mathcal{O}(1)$ more likely.

‚åÇ
<br>Ôπà<br>^1693800407441


Ôπá<br>
Why might one choose `std::map` over `std::unordered_map` for specific scenarios?

#card

When you need sorted key order, or when you want to ensure worst-case performance of $\mathcal{O}(\log n)$ for operations regardless of hash collisions.

‚åÇ
<br>Ôπà<br>^1693800407446


Ôπá<br>
If you iterate across a `std::map` in C++, will the keys be presented in a sorted order?

#card

Yes, the keys will be presented in sorted (ascending) order.

‚åÇ
<br>Ôπà<br>^1693800407452


Ôπá<br>
If you are working with a small and finite set of values, can you generally expect `std::unordered_map` operations to have $\mathcal{O}(1)$ time complexity?

#card

Yes, with a small and finite set of values, the chances for hash collisions are reduced, making $\mathcal{O}(1)$ time complexity more likely for `std::unordered_map` operations. However, the quality of the hash function and the load factor can still affect performance.

‚åÇ
<br>Ôπà<br>^1693800407457


Ôπá<br>
Is the following approach valid?

```cpp
// target = a + b
// a = target - b
#include <map>
#include <algorithm>
#include <vector>

using namespace std;

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int,int> numMap; // value, index

        vector<int> ans;

        for(int i {0}; i < nums.size(); i++) {
            int complement = target - nums[i];
            if(numMap.find(complement) == numMap.end()) {
                numMap[nums[i]] = i;
            }
            else { // We have a found the complemet
                ans.push_back(i);
                ans.push_back(numMap[complement]);
                return ans;
            }
        }

        return ans;
    }
};
```

#card 

While the above approach will compile and is logically correct, it is not _entirely_ optimal. 
- Given the relatively small maximum size for `nums` (recall that one of the **constraints** for the problem is `2 <= nums.length <= 104`), we can safely use `std::unordered_map` instead to achieve a $\mathcal{O}(1)$ worst case time complexity.
- Also, we can simply just return our answer directly instead of predeclaring an `ans` vector at the start.

Taking into account the suggestions above, here is a more ‚Äúoptimal‚Äù solution‚Ä¶

```cpp
// target = a + b
// a = target - b
#include <unordered_map>
#include <vector>

using namespace std;

class Solution {

public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> numMap; // value, index

        for(int i {0}; i < nums.size(); i++) {
            int complement = target - nums[i];
            if(numMap.find(complement) == numMap.end()) {
                numMap[nums[i]] = i;
            }
            else { // We have a found the complemet
                return {i, numMap[complement]};
            }
        }

        return {};
    }
};
```

‚åÇ
<br>Ôπà<br>^1693800407463

Ôπá<br>
In C++, can you initialize a `std::vector` without pre-declaring its size, using curly braces (`{}`)?

#card

Yes, you can initialize a `std::vector` without pre-declaring its size by using list initialization with curly braces. 

For example: 
```cpp
std::vector<int> vec = {1, 2, 3};
```

‚åÇ
<br>Ôπà<br>^1693800466082


#### Solution (Python)

Ôπá<br>
What is the _optimal_ solution to this problem? If there are multiple, list them out and compare.

#card 

**Approach #3**: One-pass Hash Table ‚úÖüåü

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        numDict = {}

        for idx,num in enumerate(nums):
            if(numDict.get(target - num) == None):
                numDict[num] = idx
            else:
                return [idx, numDict[target - num]]
        
        return []
```

- **Asymptotic Complexity**:
	- Time: $\mathcal{O}(n)$
	- Space: $\mathcal{O}(n)$

‚åÇ
<br>Ôπà<br>^1693802500582


##### Attempt #1 :: üìÜ 2023-09-03 21:00 :: ‚ùå 

###### Performance

- ‚è≤**Time**: `0:05:41`
- üßîüèΩ‚Äç‚ôÇÔ∏è **Author(s)**: 
	- `Edmund Leibert III`

###### Notes

Ôπá<br>
In Python, what is the equivalent of the `.find()` method for dictionaries that is commonly used in C++?

#card

The equivalent is using the `in` keyword to check for the existence of a key, or using `.get(key, default_value)` to retrieve the value associated with a key. `.get()` will return `None` or the specified default value if the key is not found.

In Python, dictionaries don't have a `.find()` method like C++ maps. However, you can use the `in` keyword to check if a key exists in a dictionary. If you want to retrieve the value for a given key, you can use `.get()` which returns `None` if the key is not found, or you can specify a default value.

Here are some examples:

- Using `in` to check for a key:
```python
if key in my_dict:
print("Key exists.")
```

- Using `.get()` to retrieve a value or `None`:
```python
value = my_dict.get(key)
```

- Using `.get()` with a default value:
```python
value = my_dict.get(key, "default_value")
```

‚åÇ
<br>Ôπà<br>^1693801830688


Ôπá<br>
How do you declare a **dictionary** in Python 3?

#card

In Python 3, you can declare a dictionary using curly braces `{}` with key-value pairs separated by colons. You can also use the `dict()` constructor. Here are some examples:

1. Using curly braces:
```python
my_dict = {'key1': 'value1', 'key2': 'value2'}
```

2. Using the `dict()` constructor:
```python
my_dict = dict(key1='value1', key2='value2')
```

3. An empty dictionary:
```python
my_dict = {}
```

‚åÇ
<br>Ôπà<br>^1693801830696


#### Solution (C\#)

Ôπá<br>
What is the _optimal_ solution to this problem? If there are multiple, list them out and compare.

#card 

**Approach #3**: One-pass Hash Table ‚úÖüåü

```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        Dictionary<int, int> numsMap = new Dictionary<int, int>();

        for(int i = 0; i < nums.Length; i++) {
            if(numsMap.ContainsKey(target - nums[i])) {
                return new int[] {i, numsMap[target - nums[i]]};
            }
            else {
                numsMap[nums[i]] = i;
            }
        }
        return new int[] {};
    }
}
```

- **Asymptotic Complexity**:
	- Time: $\mathcal{O}(n)$
	- Space: $\mathcal{O}(n)$

‚åÇ
<br>Ôπà<br>^1693898508588


##### Attempt #1 :: üìÜ 2023-09-03 21:20 :: ‚ùå 

###### Performance

- ‚è≤**Time**: `0:13:14`
- üßîüèΩ‚Äç‚ôÇÔ∏è **Author(s)**: 
	- `Edmund Leibert III`

###### Notes

Ôπá<br>
In C#, what is the equivalent of a **map** in C++? 

#card 

The equivalent of a map in C++ is a `Dictionary` in C#.

```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        // Declare and initialize a Dictionary
        Dictionary<string, int> myDictionary = new Dictionary<string, int>();

        // Adding key-value pairs
        myDictionary.Add("apple", 1);
        myDictionary.Add("banana", 2);
        myDictionary.Add("cherry", 3);

        // Another way to add or update a key-value pair
        myDictionary["apple"] = 1;

        // Access a value by key
        int value = myDictionary["apple"];

        Console.WriteLine(value);  // Output will be 1
    }
}
```

‚åÇ
<br>Ôπà<br>^1693804889554


Ôπá<br>
Do you need to import a library to use `Dictionary` in C#?

#card

Yes, you need to import the `System.Collections.Generic` namespace to use `Dictionary`.

‚åÇ
<br>Ôπà<br>^1693804889565


Ôπá<br>
How do you declare and initialize a `Dictionary` in C#?

#card 

You declare and initialize a `Dictionary` in C# using the syntax `Dictionary<KeyType, ValueType> myDictionary = new Dictionary<KeyType, ValueType>();`.

‚åÇ
<br>Ôπà<br>^1693804889572



Ôπá<br>
Can you enumerate across `Dictionary` in C# like in Python?

#card 

Yes, you can enumerate through a `Dictionary` in C# similarly to how you would in Python. The `Dictionary` type provides different ways to iterate through its elements.

Here are a few methods:

1. **Iterate through Keys and Values:**
```csharp
foreach (KeyValuePair<string, int> kvp in myDictionary)
{
	Console.WriteLine($"Key: {kvp.Key}, Value: {kvp.Value}");
}
```

2. **Iterate through Keys only:**
```csharp
foreach (string key in myDictionary.Keys)
{
	Console.WriteLine($"Key: {key}");
}
```

3. **Iterate through Values only:**
```csharp
foreach (int value in myDictionary.Values)
{
	Console.WriteLine($"Value: {value}");
}
```

‚åÇ
<br>Ôπà<br>^1693804889580


Ôπá<br>
Can you enumerate across an `int[]` array in C#?

#card

Yes, you can enumerate through an `int[]` array in C# using a `foreach` loop, similar to Python's `for` loop over a list. Here's how you do it:

```csharp
int[] myArray = {1, 2, 3, 4, 5};

foreach (int item in myArray)
{
    Console.WriteLine(item);
}
```

This will output each element in the array, one per line.

You can also use a traditional `for` loop if you need the index:

```csharp
for (int i = 0; i < myArray.Length; ++i)
{
    Console.WriteLine($"Index: {i}, Value: {myArray[i]}");
}
```

‚åÇ
<br>Ôπà<br>^1693804889587


Ôπá<br>
Is there a built-in `enumerate` function like in Python for C#? 

#card

C# doesn‚Äôt have a built-in `enumerate` function like Python, which allows you to iterate through items in a collection while also keeping track of the index. 

However, you can easily replicate this functionality using a `for` loop and the `Length` property for arrays or the `Count` property for collections like `List<T>`.

Here's an example using a `for` loop with an array:

```csharp
int[] myArray = {1, 2, 3, 4, 5};
for (int i = 0; i < myArray.Length; i++)
{
    Console.WriteLine($"Index: {i}, Value: {myArray[i]}");
}
```

You can also use LINQ to achieve similar functionality, though it might be a bit more verbose:

```csharp
using System.Linq;

// ...

int[] myArray = {1, 2, 3, 4, 5};
foreach (var (item, index) in myArray.Select((value, index) => (value, index)))
{
    Console.WriteLine($"Index: {index}, Value: {item}");
}
```

‚åÇ
<br>Ôπà<br>^1693804889594


Ôπá<br>
How can I access the size of a container in C#?

#card

The way you access the size of a container in C# varies depending on the type of the container. Here are some common cases:

1. **Array**: Use the `Length` property.
```csharp
int[] myArray = {1, 2, 3};
int size = myArray.Length;
```

2. **List**: Use the `Count` property.
```csharp
List<int> myList = new List<int> {1, 2, 3};
int size = myList.Count;
```

3. **Dictionary**: Use the `Count` property.
```csharp
Dictionary<string, int> myDictionary = new Dictionary<string, int>();
myDictionary.Add("one", 1);
int size = myDictionary.Count;
```

4. **Collection interfaces** like `ICollection` or `IList`: Use the `Count` property.
```csharp
ICollection<int> myCollection = new List<int> {1, 2, 3};
int size = myCollection.Count;
```

‚åÇ
<br>Ôπà<br>^1693804889602



Ôπá<br>
Can you use collection initializers in C# to initialize lists, dictionaries, and other collections in a manner similar to list initialization in C++?

#card

Yes, you can use collection initializers in C# to initialize lists, dictionaries, and other collections in a manner similar to list initialization in C++. For example:

1. **List Initialization**
```csharp
List<int> myList = new List<int> {1, 2, 3, 4, 5};
```

2. **Dictionary Initialization**
```csharp
Dictionary<string, int> myDictionary = new Dictionary<string, int>
{
	{"one", 1},
	{"two", 2},
	{"three", 3}
};
```

3. **Array Initialization**
```csharp
int[] myArray = {1, 2, 3, 4, 5};
```

Note that the collection initializers in C# are not exactly the same as list initialization in C++ but serve a similar purpose of making the code more readable and concise.

‚åÇ
<br>Ôπà<br>^1693804889610



Ôπá<br>
Does C# support direct brace initialization?

#card 

The direct brace initialization syntax for single variables, like `int x{2};` in C++, is not available in C#. In C#, you would typically use the assignment operator for primitive types:
^1693804889618

```csharp
int x = 2;
```

C# does not offer the brace initialization syntax for primitives, but it does have various ways to initialize objects and collections as previously mentioned.

‚åÇ
<br>Ôπà<br>^1693804889625

Ôπá<br>
Is the following code valid?

```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        Dictionary<int, int> numMap;

        for(int i = 0; i < nums.Length; i++) {
            if(numMap.find(target - nums[i]) == None) {
                numMap[nums[i]] = i;
            }
            else {
                return {i, nums[i]};
            }
        }
        return {};
    }
}
```

#card 

Several issues exist in your C# code. Let's go through them:

1. `numMap` is declared but not initialized. You should initialize it before using it.

1. The `find` method does not exist in C# for dictionaries; use `ContainsKey` instead.

2. `None` is not a keyword in C#; you should use `null`.

3. Arrays in C# don't support Python-style dynamic list initialization with 

	```csharp
	{}
	```

	directly in a `return` statement. Use the following instead‚Ä¶
	
	```csharp
	new int[] {...} 
	```

1. Remember that 

	```csharp
	return {};
	```

	 is also not valid for the same reason as point 4.

6. Instead of returning `i` and `nums[i]`, you should return `i` and the value from `numMap` which corresponds to the index of the matching number.

Here's the corrected version of your code:

```csharp
using System;
using System.Collections.Generic;

public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        Dictionary<int, int> numMap = new Dictionary<int, int>();

        for(int i = 0; i < nums.Length; i++) {
            if(!numMap.ContainsKey(target - nums[i])) {
                numMap[nums[i]] = i;
            }
            else {
                return new int[] {i, numMap[target - nums[i]]};
            }
        }
        return new int[] {};
    }
}
```

‚åÇ
<br>Ôπà<br>^1693805526277


Ôπá<br>
How do you initialize a Dictionary in C#?

#card

Use `new Dictionary<K, V>()` to initialize a Dictionary.

‚åÇ
<br>Ôπà<br>^1693805526284


Ôπá<br>
What method should you use to check if a key exists in a C# Dictionary?

#card

Use `ContainsKey` instead of `find` for checking key existence.

‚åÇ
<br>Ôπà<br>^1693805526291


Ôπá<br>
What is the equivalent of Python's `None` in C#?

#card

Use `null` instead of `None`.

‚åÇ
<br>Ôπà<br>^1693805526301


Ôπá<br>
How do you initialize an array with values in C#?

#card

Use `new int[] {...}` for array initialization, not `{}` directly.
^1693805526309

‚åÇ
<br>Ôπà<br>^1693805526319


Ôπá<br>
How do you initialize an empty array in C#?

#card

For empty arrays, use `new int[] {}`.

‚åÇ
<br>Ôπà<br>^1693805526328





---

## üîú Next Note(s):

---
