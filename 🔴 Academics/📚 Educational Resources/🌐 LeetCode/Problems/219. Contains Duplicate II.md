---
title: 219. Contains Duplicate II
created: 2023-09-10 17:06
updated: 2023-09-11 00:05
authors:
  - Edmund Leibert III
tags:
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-leetcode
  - ğŸ”´-academics/ğŸ“š-educational-resources/source-format/internet/website
  - ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-leetcode/ğŸ”–-bookmark/ğŸŒ-leetcode/problems/219-contains-duplicate-ii
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-leetcode/ğŸ·ï¸-tag/problem/difficulty/easy
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-leetcode/ğŸ·ï¸-tag/problem/tag/topic/array
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-leetcode/ğŸ·ï¸-tag/problem/tag/topic/hash-table
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-leetcode/ğŸ·ï¸-tag/problem/tag/topic/sliding-window
  - study-note
cards-deck: ğŸ”´ Academics::ğŸ“š Educational Resources::ğŸŒ LeetCode::Problems::219. Contains Duplicate II
---

# ğŸŒ Structy

---

## ğŸ•¸ï¸ All Mention(s): 

---

## ğŸ”™ Previous Note(s):

---

## 0. Introduction

### 219. Contains Duplicate II

> [!info]+ Where can the problem be found?
> The problem can be found here: [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/)

#### Solution (C++)

ï¹‡<br>
What is the _optimal_ solution to this problem? Provide analysis regarding what differentiates it to other approaches/solutions.

#card 

**Approach #3: Hash Table** â­

```cpp
#include <unordered_map>
#include <cmath>

using namespace std;

class Solution {
public:
	bool containsNearbyDuplicate(vector<int>& nums, int k) {
		unordered_map<int, int> numMap; // val, pos
		if(nums.empty() || nums.size() == 1) {
			return false;
		}
		for(int i {0}; i < nums.size(); i++) {
			if (numMap.find(nums[i]) == numMap.end()) {
				numMap[nums[i]] = i;
				if(numMap.size() > k) {
					numMap.erase(nums[i - k]);
				}
			}
			else {
				if( abs(i - numMap[nums[i]]) <= k ) {
					return true;
				}
			}
		}
		return false;
	}
};
```
	
- **Intuition**
	- Keep a sliding window ofÂ $k$Â elements using Hash Table.
- **Algorithm**
	- From the previous approaches, we know that even logarithmic performance inÂ `search`Â is not enough. In this case, we need a data structure supporting constant timeÂ `search`,Â `delete`Â andÂ `insert`Â operations. Hash Table is the answer. The algorithm and implementation are almost identical toÂ [Approach #2](https://leetcode.com/problems/contains-duplicate-ii/editorial/#approach-2-binary-search-tree-time-limit-exceeded).
	- Loop through the array, for each element do
		- Search current element in the HashTable, returnÂ `true`Â if found
		- Put current element in the HashTable
		- If the size of the HashTable is larger thanÂ $k$, remove the oldest item.
	- ReturnÂ `false`
- **Complexity Analysis**
	- **Time Complexity**:Â $\mathcal{O}(n)$.  
		- We doÂ $n$ operations ofÂ `search`,Â `delete`Â andÂ `insert`, each with constant time complexity.
	- **Space Complexity**:Â $\mathcal{O}(min(n,k))$.  
		- The extra space required depends on the number of items stored in the hash table, which is the size of the sliding window,Â $\mathcal{O}(min(n,k))$.

âŒ‚
<br>ï¹ˆ<br>^1694399078847



##### Attempt #1 :: 2023-09-10 17:09 -07:00 :: âŒ :: \[Author: Edmund Leibert III\]

###### Performance

- â²ï¸ **Time**: `0:20:00`
- ğŸ§”ğŸ½â€â™‚ï¸ **Author(s)**:
	- Edmund Leibert III

###### Notes

ï¹‡<br>
In C++, does `unordered_map` support the method `.remove()`?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

No, you should instead use the `erase()` function. Remember, to remove a key and its associated value from an `unordered_map` in C++, you can use the `erase` function. Here is an example:

```cpp
#include <unordered_map>

int main() {
    std::unordered_map<int, int> myMap;

    // Insert a key-value pair into the map
    myMap[1] = 100;

    // Remove the key-value pair with key 1
    myMap.erase(1);

    return 0;
}
```

In this code, `myMap.erase(1);` removes the key-value pair from the map where the key is `1`. If the key does not exist in the map, this operation has no effect.

âŒ‚
<br>ï¹ˆ<br>^1694399078857




ï¹‡<br>
In C++, how can you remove a _key_ and its associated _value_ in an `std::unordered_map` in C++ using just the _key_?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

```cpp
#include <unordered_map>

int main() {
    std::unordered_map<int, int> myMap;

    // Insert a key-value pair into the map
    myMap[1] = 100;

    // Remove the key-value pair with key 1
    myMap.erase(1);

    return 0;
}
```


âŒ‚
<br>ï¹ˆ<br>^1694399078862




ï¹‡<br>
Is the following code valid?

```cpp
#include <unordered_map>

int main() {
    std::unordered_map<int, int> myMap;

    // Insert a key-value pair into the map
    myMap[1] = 100;

    // Remove the key-value pair with key 1
    myMap.remove(1);

    return 0;
}
```

#card 

No, the above code will _not_ compile.
- This is because `std::unordered_map` does not have a `remove()`  function. One should instead use `erase()`.

âŒ‚
<br>ï¹ˆ<br>^1694399078867



ï¹‡<br>
When using a **map** when iterating across a container to find values in a window that satisfy a certain condition, how can you ensure that the â€œwindowâ€ slides? 

#card 

When using this approach our â€œsliding windowâ€ is represented in our **map**, as such, we need to decrement the earliest incremented key-value pair that was inserted into the map.

âŒ‚
<br>ï¹ˆ<br>^1694399078872


---

## ğŸ”œ Next Note(s):

---

