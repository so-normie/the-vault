---
title: "003. max-value ğŸ‘¨ğŸ½â€ğŸ’»"
created: 2023-08-04 01:58 
authors: [Edmund Leibert III]
tags: 
- ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-structy
- ğŸ”´-academics/ğŸ“š-educational-resources/source-format/internet/website
- ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science
- ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-structy/ğŸ”–-bookmark/ğŸŒ-structy/0-introduction/003-max-value-ğŸ§‘ğŸ½â€ğŸ’»
- ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-structy/ğŸ·ï¸-tag/challenge
- study-note
cards-deck: ğŸ“š Educational Resources::ğŸŒ Structy::0. Introduction::003. max-value ğŸ§‘ğŸ½â€ğŸ’»
---

# ğŸŒ Structy

---

## ğŸ•¸ï¸ All Mention(s): 

---

## ğŸ”™ Previous Note(s):

---

## 0. Introduction

### 003. max-value ğŸ‘¨ğŸ½â€ğŸ’»

#### Solution (C++)

What is/are the most **optimal** solution(s) for this problem? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- **Approach #1**: Using the `max_element()` function
	1. Just use the `std::max_element()`!
	- **Computational Complexity**:
		- Time: $\mathcal{O}(n)$
		- Space: $\mathcal{O}(1)$
- **Approach #2**: Using pointers
	1. Create a variable called `maxValue` that will be initially set to the `numeric_limits<int>::max()`.
	2. Iterate across the container.
		1. If the current `maxValue` is less than the current value, set `maxValue` to that value.
	- **Asymptotic Analysis**:
		- Time: $\mathcal{O}(n)$
		- Space: $\mathcal{O}(1)$
- âŒ‚
^1690056204664

##### Attempt #1 (2023-22-07) â²ï¸ 00:04:00

In C++, how can you represent negative or positive infinity? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- One can use the <span class="spoiler">`limits`</span> library, which is part of the C++ Standard library.
- With that, you can use the function `numeric_limits<int>â–¹infinity()` to call postive infinity of the type `int`. 
- If you wanted to negative infinity, you can simply do `-numeric_limits<int>â–¹infinity()` to call negative infinity of the type `int`. 
^1684976004949

What is the downside of using `numeric_limits<int>::infinity()` than just using `numeric_limits<int>::double()`?
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- `std::numeric_limits<int>::infinity()` return the representation of positive, **if available**. 
- However, `std::numeric_limits<int>::has_inifinity` returns `false` for `int`, meaning that `std::numeric_limits<int>::infinity()` does not return any meaningful value to compare with.
^1690056204669

How can I check the if a data type supports infinity? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
Use the `std::numeric_limits<int>::has_inifinity` to check if the value returned from that expression is `true` or `false`.
^1690056204674

When trying to assign the value *negative* infinity (of type `int`) via the `<limits>` library, where should one place the negative sign?
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
`-numeric_limits<int>â–¹infinity()` Note that the negative sign is placed *before* the whole expression.
^1684976004952

What does the `â–¹` mean in the expression `numeric_limits<int>â–¹infinity()`?
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- In C++ programming language, theÂ `::`Â is called theÂ **scope resolution operator**. 
- It is used to specify the scope of a function or variable. 
	- In this case,Â `numeric_limits<int>::infinity()`Â means that theÂ `infinity()`Â function is being called from theÂ `numeric_limits`Â class template specialized for theÂ `int`Â type. 
^1684976004965

What does `numeric_limits<int>::lowest()` return when the data type is of `int`?
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- Returns the lowest  possible (negative) value of `int`
- Same as `numeric_limits<int>::min()`
^1690056204678


What does `numeric_limits<int>::min()` return when the data type is of `int`?
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- Returns the lowest  possible (negative) value of `int`
- Same as `numeric_limits<int>::lowest()`
^1690056204683

What does `numerc_limits<int>::min()` return when the data type is of a floating-point type (i.e., `double`, `float`)? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- Return the minimum positive normalized value.
- Note, how this is different from when the data type is `int`.
^1690056204688


What does `numerc_limits<int>::min()` return when the data type is of a floating-point type?  
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- Return the lowest value (which can be negative) of the type.
^1690056204693


What can `double` and `float` be classified as?  
#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 
 They can be classified as **floating point** data points.
^1690056227110


In C++, what is the difference between iterator based loops vs range-`for` loop?  
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- First and foremost, use range-`for` loops.
- A range-`for` loop uses iterators internally. The loop variable is the *dereferenced value*, not the iterator itself.
^1684976004969


In C++, does a range-`for` loop expose access to its internal iterators?  
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
A range-`for` loop does *not* expose access to its internal iterators.
^1684976004973


What are **containers** in C++?  
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- In C++, containers are data structures that store and organize a collection of objects in memory.
- They are parts of the C++ Standard Library and provide a convenient way to manage collections of data, offering different trade-offs in terms ofâ€¦
	- performance
	- memory usage
	- functionality
- âŒ‚
^1684976004977


What are the main categories of containers in C++? 
#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 
The main categories of <span class="spoiler">containers</span>â€¦
- Sequence containers
- Associative containers
- Unordered associative containers
- Container adapters
^1684976004982

What type of container is `queue`?  
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
container adaptor
^1691047491098

What type of container is `stack`?  
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
container adaptor
^1691047491103

What are sequence containers?  
#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 
- Store elements in a linear sequence, where each element has a specific position.
- Examples includeâ€¦
	- <span class="spoiler">`stdâ–¹vector`</span>: <span class="spoiler">A dynamic array that automatically resizes itself whenits capacity is exceeded. It provides fast random access and efficient insertions/deletion at the end, but inertions/deletions in the middle can be slow.</span> 
	- <span class="spoiler">`stdâ–¹list`</span>: <span class="spoiler">A doubly-linked list that allows for fast insertinos and deletions at any position, but does not support random access.</span>
	- <span class="spoiler">`stdâ–¹deque`:</span> <span class="spoiler">A double-ended queue that supports fast random access and efficient insertions/deletions at both the beginning and the end.</span>
	- <span class="spoiler">`stdâ–¹forward_list` (sinceC++11)</span>: <span class="spoiler">A singly-linked list that allows for fast insertions and deletions at any position, but does not support random access or bidirectional traversal.</span>
	- <span class="spoiler">`stdâ–¹array` (sineC++11)</span>: <span class="spoiler">A fixed-size array with a compile-time size, providing fast random access and a small memory footprint.</span>
^1684976004986


What are associative and unordered associative containers?  
#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 
- These containers store elements in a sorted or hashed manner, which allows for faster access, insertion, and deletion based on specific keys.
- Examples includeâ€¦
	- <span class="spoiler">`stdâ–¹set`</span>: <span class="spoiler">A sorted collection of unique elements, typically implemented as a balanced binary search tree.</span>
	- <span class="spoiler">`stdâ–¹multiset`</span>: <span class="spoiler">Similar to `stdâ–¹set`, but allows multiple instances of the same element.</span>
	- <span class="spoiler">`stdâ–¹map`</span>: <span class="spoiler">A sorted collection of key-value pairs, with unique keys, typically implemented as a balanced binary search tree.</span>
	- <span class="spoiler">`stdâ–¹multimap`</span>: <span class="spoiler">Similar to `stdâ–¹map`, but allows multiple key-value pairs with the same key.</span>
	- <span class="spoiler">`stdâ–¹unordered_set` (sinceC++11)</span>: <span class="spoiler">A hashed collection of unique elements, providing average constant-time access, insertion, and deletion.</span>
	- <span class="spoiler">`stdâ–¹unordered_multiset` (sinceC++11)</span>: <span class="spoiler">Similar to `stdâ–¹unordered_set`, but allows multiple instances of the same element.</span>
	- <span class="spoiler">`stdâ–¹unordered_map` (sinceC++11)</span>: <span class="spoiler">A hashed collection of key-value pairs, with unique keys, providing average constant-time access, insertion, and deletion.</span>
	- <span class="spoiler">`stdâ–¹unordered_multimap` (sinceC++11)</span>: <span class="spoiler">Similar to `stdâ–¹unordered_map`, but allows multiple key-value pairs with the same key.</span>
- âŒ‚
^1684976004989


What are some key benefits of containers in C++?  
#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- These containers provide various iterator types that allow you to traverse and manipulate the elements in a uniform manner.
- Additionally, they are designed to worth withC++ standard library algorithms, which makes it easy to perform common operations such asâ€¦
	- <span class="spoiler">searching elements</span>
	- <span class="spoiler">sorting elements</span>
	- <span class="spoiler">transforming elements</span>
- âŒ‚
^1684976004994


In C++, what is an input iterator?  
#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- A type of iterator that allows you to traverse a container in a read-only, forward direction.
	- It is the most basic iterator category in theC++ Standard Library
	- Provides the minimum functionality required for single-pass algorithms, like reading elements from an input stream, or iterating through elements of a container in a linear fashion.
- âŒ‚
^1684976004998


What requirements must an iterator satisfy?  
#card-reverse #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
 *Donâ€™t worry about this too much*
1. <span class="spoiler">Copy-constructible:</span>
2. <span class="spoiler">Copy-assignable:</span>
3. <span class="spoiler">Destructible:</span>
4. <span class="spoiler">Equality-comparable:</span>
5. <span class="spoiler">Incrementable/Decrementable:</span>
^1684976005002


What operations does an input iterator satisfy? 
#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
1. <span class="spoiler">Dereference (`*`):</span> <span class="spoiler">Access the value pointed to by the iterator (read-only</span>
2. <span class="spoiler">Increment (`++`):</span> <span class="spoiler">Move the iterator to the next element in the container.</span>
3. <span class="spoiler">Equality comparison (`==`):</span> <span class="spoiler">Check if two iterators are equal (point to the same element).</span>
4. <span class="spoiler">Inequality comparison (`!=`):</span> <span class="spoiler">Check if two iterators are not equal (point to different elements).</span>
^1684976005005

First and foremost, what exactly is an `input_iterator`?  
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- To provide more context, an input iterator is a type of iterator that is part of a collection/new way of organizing iterators called â€œ[Iterator concepts](https://en.cppreference.com/w/cpp/iterator).â€
	- While, I am still unsure about what the difference is between an `input_iterator` and a `output_iterator`, we need not concern ourselves for now.
- âŒ‚
^1691032903994

What type of iterator is returned when calling the method `.begin()` of a `forward_list`?  
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
It returns a `forward_iterator`
^1691032904002

What type of iterator can only be incremented (i.e., can not be decremented)?  
#card-reverse  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
`forward_iterator`s 
Refer to the this for more information: [C++ named requirements: LegacyInputIterator - cppreference.com](https://en.cppreference.com/w/cpp/named_req/InputIterator)
^1684976005009

What are some containers that return forward iterators?  
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- `stdâ–¹istream_iterator` for reading from input streams
- iterator types used by `stdâ–¹forward_list` 
^1684976005014

What are three types of forms of ranged-based `for` loops using the keyword `auto`?  
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
```cpp
// The auto keyword causes type inference to be used. Preferred. 
for( auto y : x ) { // Copy of 'x', almost always undesirable 
	cout << y << " ";
} 
cout << endl;
for( auto &y : x ) { // Type inference by reference.
	// Observes and/or modifies in-place. Preferred when modify is needed. 
	cout << y << " ";
} 
cout << endl; 
for( const auto &y : x ) { // Type inference by const reference.
	// Observes in-place. Preferred when no modify is needed.
	cout << y << " ";
}
```
^1684976005017

What is the difference between `stdâ–¹numeric_limits<float>â–¹infinity()` and `stdâ–¹numeric_limits<float>â–¹lowest()`?  
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- One returns just the lowest *finite* value while the other returns a special value marked as â€œpositive infinity.â€
- Refer below to see what the console outputs when calling the commandâ€¦
```bash
-3.40282e+38
inf
```
^1687571900415

What was my initial approach?  
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
**Computational Complexity**:
<span class="spoiler">Time: $O(n)$</span>
<span class="spoiler">Space: $O(1)$</span>
1. <span class="spoiler">Create a variable `maxNum` that is negative infinity
	- Note that this is our â€œbase caseâ€, all values in our list must be equal or greater.</span>
2. <span class="spoiler">Iterate across all the elements in the container linearly
	- If `maxNum` is less than some element, maxNum is equal to that element.</span>
3. <span class="spoiler">Finish iterating and return `maxNum`</span>
^1684976005021

#### Solution (Python)

##### Attempt #1 (2023-22-07) â²ï¸ 00:04:00

#### Solution (JavaScript)

##### Attempt #1 (2023-22-07) â²ï¸ 00:04:00


---

## ğŸ”œ Next Note(s):
- [[ğŸ”´ Academics/ğŸ“š Educational Resources/ğŸŒ Structy/0. Introduction/004. is prime ğŸ‘¨ğŸ½â€ğŸ’»|004. is prime ğŸ‘¨ğŸ½â€ğŸ’»]]

---
