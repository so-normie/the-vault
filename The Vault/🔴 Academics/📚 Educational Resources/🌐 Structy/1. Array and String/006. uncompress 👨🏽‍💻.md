---
title: "006. uncompress ğŸ‘¨ğŸ½â€ğŸ’»"
created: 2023-08-04 01:58 
authors: [Edmund Leibert III]
tags: 
- ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-structy
- study-note
cards-deck: Default::Computer Science
---

# ğŸŒ Structy

---

## ğŸ•¸ï¸ All Mention(s): 

---

## ğŸ”™ Previous Note(s):

---

## 1. Array and String

### **006. uncompress ğŸ‘¨ğŸ½â€ğŸ’»**

#### Solution (C++)

What is/are the most **optimal** solution(s) for this problem? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 
â— To be filled.
^1692362504176


##### **Attempt #1 (2023-25-06) â²ï¸ 00:08:00**

What was my initial approach to solving this problem? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- Iterate across the input string
- If the current char is *not* a char, push the assumed `int` into a â€œnumbersâ€ string
- If a char, append the char â€œnumbersâ€ amount of times to the result.  Reset numbers.
- Example code below...
```cpp
#include <string>
std::string uncompress(std::string s) {
  // todo
  std::string result = "";
  std::string patternLength = "";
  int length {0};
  for(int i{0}; i < s.length(); i++) {
    if(isdigit(s.at(i))) { // if digit, append
      patternLength.push_back(s.at(i));
    }
    else { //if not a digit
      length = std::stoi(patternLength);
      while(length > 0) {
        result.push_back(s.at(i));
        length--;
      }
      patternLength = "";
      length = 0;
    }
  }
  return result;
}
void run() {
  // this function behaves as `main()` for the 'run' command
  // you may sandbox in this function, but should not remove it
}
```
^1687765735590


What was wrong with my initial approach? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
While correct, takes a little too long and does not the *two pointer* method.
^1687765735596


What is the difference between using indexing (i.e. brackets) to access the position of a string vs using the `at()` method in C++? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- The main difference between using indexing (`[]`) and the `at()` method to access a character in a string in C++ is that the `at()` method performs bounds checking and throws an exception if the index provided is out of bounds Â³. On the other hand, using indexing (`[]`) to access an out-of-bounds index results in undefined behavior â´.
- In summary, using the `at()` method is safer because it will throw an exception if you try to access an out-of-bounds index, while using indexing (`[]`) can result in undefined behavior if you accidentally access an out-of-bounds index âµ.
- **Source**: Conversation with Bing, 6/23/2023
  (1) c++ - Difference between std::string - Stack Overflow. https://stackoverflow.com/questions/50687711/difference-between-stdstring-operator-and-at.
  (2) How to access an element of a vector using index in C++. https://www.codevscolor.com/c-plus-plus-access-element-of-vector.
  (3) c++ - What is the difference between string::at and string::operator .... https://stackoverflow.com/questions/14699060/what-is-the-difference-between-stringat-and-stringoperator.
  (4) c++ - vector::at vs. vector::operator[] - Stack Overflow. https://stackoverflow.com/questions/9376049/vectorat-vs-vectoroperator.
  (5) string at() in C++ - GeeksforGeeks. https://www.geeksforgeeks.org/string-at-in-cpp/.
^1687765735602


##### **Attempt #2 (2023-25-06) â²ï¸ 00:08:00**

Lets lets consider the case that I have two pointers pointing to the 2nd and 5th position of a string. With the two pointers, how can I get the character width between these two? For instance, in this case, the character width between these two pointers would be 4 (we are excluding the 5th position). 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
Yes, in modern C++, you can use the `std::distance` function from the `<iterator>` header to calculate the distance between two iterators or pointers. Here's an updated example using `std::distance`: 
```cpp
#include <iostream>
#include <string>
#include <iterator>
int main() {
    std::string str = "Hello, World!";
    auto ptr1 = std::next(str.begin(), 1);  // Iterator to the 2nd position
    auto ptr2 = std::next(str.begin(), 4);  // Iterator to the 5th position
    int width = std::distance(ptr1, ptr2);
    std::cout << "Character width: " << width << std::endl;
    return 0;
}
```
In this example, `std::next` is used to obtain iterators pointing to the desired positions in the string. Then, `std::distance` is used to calculate the distance between these iterators, which gives us the character width between the two positions. The output will still be 4, indicating the number of characters between the 2nd and 5th positions (excluding the 5th position).
^1687765735608


What function in C++ can I use to get a **substring** of a string if I just have the positions represented as `int`s? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- In C++, you can use the `substr` function to extract a part of a string. The `substr` function takes two arguments: the starting position (index) of the substring and the length of the substring. Here's an example:
```cpp
#include <iostream>
#include <string>
int main() {
	std::string str = "Hello, World!";
	// Extract a substring starting from position 7 with length 5
	std::string substring = str.substr(7, 5);
	std::cout << "Substring: " << substring << std::endl;
	return 0;
}
```
- In this example, `str` is the original string, and we want to extract a substring starting from position 7 (inclusive) with a length of 5 characters. The resulting substring is "World". The `substr` function returns a new string containing the extracted part.
- Note that string indexing in C++ starts from 0, so the first character of the string is at index 0. The extracted substring includes the starting position and continues for the specified length.
- You need to include the `<string>` header to use the `substr` function.
^1687765735613


What function in C++ can I use to get a **substring** of a string if I just have the positions represented as pointers? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- Should use the `string()` function as seen below to just build a new stringâ€¦
```cpp
std::string uncompress(std::string s) {
// todo
const char* frontPtr = &s[0];
const char* backPtr = &s[0];
int dis {0};
std::string result = "";
while(*frontPtr != '\0') {
	// if a char, sue to create the group to append to result
	if(isalpha(*frontPtr)) {
		// Get the group length
		dis = std::stoi(std::string(backPtr,frontPtr));
		while(dis != 0) {
			result.push_back(*frontPtr);
			dis--;
		}
		dis = 0;
		backPtr = frontPtr + 1;
	}
	frontPtr++;
}
return result;
}
```
Done!
^1687765735620

How can I check if a character is a letter in C++? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- To check if a character is a letter in C++, you can use the `std::isalpha` function from the `<cctype>` header. Here's an example: 
```cpp
#include <iostream>
#include <cctype>
int main() {
	char ch = 'A';
	if (std::isalpha(ch)) {
		std::cout << "The character is a letter." << std::endl;
	} else {
		std::cout << "The character is not a letter." << std::endl;
	}
	return 0;
}
```
- In this example, the `isalpha` function is used to check if the character `ch` is a letter. If it is, the program outputs "The character is a letter." Otherwise, it outputs "The character is not a letter."
- Make sure to include the `<cctype>` header and prefix the `isalpha` function with `std::` since it is defined within the `std` namespace. 
^1687765735626

When should I use **string** instead of **stringstream**? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- If you're only concatenating strings useÂ `string::append`Â (orÂ [`string::operator+=`](http://en.cppreference.com/w/cpp/string/basic_string/operator+=)).
- If you're going to convert numbers to their string representation, as well as format them during conversion, and then append the conversion results together, use stringstreams. I mention the formatting part explicitly because if you do not require formatting C++11 offersÂ [`std::to_string`](http://en.cppreference.com/w/cpp/string/basic_string/to_string)Â which can be used to convert numeric types to strings.
  For example, refer to how the code is used belowâ€¦
	```cpp
	#include <sstream>
	#include <cctype>
	std::string uncompress(const std::string& s) {
	    std::stringstream ss;
	    std::string result;
	    for(auto it = s.begin(); it != s.end(); ++it) {
	        if(std::isdigit(*it)) {
	            ss << *it;
	        } else if(std::isalpha(*it)) {
	            int count = 0;
	            ss >> count;
	            result.append(count, *it); // append *it 'count' times to result
	            ss.clear(); // clear the stringstream for next number
	        }
	    }
	    return result;
	}
	```
- Done!
^1687765735631

What is the difference between `string.append()` and `string.push_back()` in C++? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- `std::string::append` and `std::string::push_back` are both used to append characters to a string in C++. The difference between them lies in their implementation and application. `std::string::append` lets you specify the appended value by using multiple arguments and has a time complexity of O(n). On the other hand, `std::string::push_back` lets you append a single character at a time and has a time complexity of O(1)Â¹.
- For example, you can append a full string using `std::string::append`, but you cannot do so using `std::string::push_back`. Similarly, you can append part of a string using `std::string::append`, but you cannot do so using `std::string::push_back`Â¹.
- **Source**: Conversation with Bing, 6/26/2023
  (**1**) std::string::append vs std::string::push_back() vs Operator += in C++. https://www.geeksforgeeks.org/stdstringappend-vs-stdstringpush_back-vs-operator-c/.
  (**2**) C++ Question about .append () vs .push_back () for Strings and .... https://stackoverflow.com/questions/76518863/c-question-about-append-vs-push-back-for-strings-and-characters-beginne.
  (**3**) std::string::push_back() in C++ - GeeksforGeeks. https://www.geeksforgeeks.org/stdstringpush_back-in-cpp/.
^1687766251956

In C++, how can I specify I wish to append a character `count` times? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
```cpp
result.append(count, *it) // append *it 'count' times to result
```
^1687766382335

In C++, how can I create a `std::string` that contains â€˜yâ€™ 127 times? 
#card
 #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
 ```cpp
std::string expected_result(127, 'y'); // this creates a string of 127 'y's
```
^1687766504192

In C++, how I clear a stream? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
Call the method `clear()` from the stream. For example: `ss.clear()` 
^1687766725529

In C++, lets say I want to extract numbers from a string as I iterate across it and then transfer it to a variable count. How would I go about this using streams in C++? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
```cpp
#include <sstream>
#include <cctype>
std::string uncompress(const std::string& s) {
    std::stringstream ss;
    std::string result;
    for(auto it = s.begin(); it != s.end(); ++it) {
        if(std::isdigit(*it)) {
            ss << *it;
        } else if(std::isalpha(*it)) {
            int count = 0;
            ss >> count;
            result.append(count, *it); // append *it 'count' times to result
            ss.clear(); // clear the stringstream for next number
        }
    }
    return result;
}
```
^1687766725537

What is meant about C++ streams providing buffering? How is this different from `std::strings`? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- Buffers in C++ streams serve as an intermediary area where data can be stored temporarily while it's being transferred between two places in your program (such as between your program and the console, a file, or a string). The data you write to a stream might be stored in a buffer first, and then actually sent to its final destination when the buffer is flushed. Similarly, when reading data from a stream, the data might be read into a buffer first, and then your program reads from that buffer.
- Buffering provides several advantages:
	1. **Efficiency**: Reading or writing data one byte at a time can be slow, because each read or write operation might require a system call, which is expensive. By reading or writing larger chunks of data at a time, you can reduce the number of system calls and improve the performance of your program.
	2. **Flexibility**: Buffers allow for flexible ordering of I/O operations. For example, you can write data to a buffer in non-contiguous chunks, and it will be written out as one contiguous chunk when the buffer is flushed.
	3. **Smooth handling of data streams**: In real-time applications, buffers can store incoming data when it arrives faster than it can be processed, and release it when the program is ready.
- Strings, on the other hand, are just sequences of characters. They don't have built-in support for buffering because they don't involve transfer of data in the same way that I/O streams do. You can, however, create a buffer-like behavior with strings by concatenating many small strings into a larger one before doing a more expensive operation (like writing the string to a file), but this is a manual process and doesn't have the automatic flushing behavior of a real buffer.
- In the case of `std::stringstream`, the stream internally uses a string as its buffer. This allows you to take advantage of the buffering behavior while working with strings.
^1687767007401

What was my second attempt for this problem? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
```cpp
#include <string>
#include <cctype>
// Time: O(n * m) n = # of groups, m = max length of group
// Space: O(n * m)
std::string uncompress(std::string s) {
    // todo
    const char* frontPtr = &s[0];
    const char* backPtr = &s[0];
    int dis {0};
    std::string result = "";
    while(*frontPtr != '\0') {
        // if a char, sue to create the group to append to result
        if(isalpha(*frontPtr)) {
            // Get the group length
            dis = std::stoi(std::string(backPtr,frontPtr));
            while(dis != 0) {
                result.push_back(*frontPtr);
                dis--;
            }
            dis = 0;
            backPtr = frontPtr + 1;
        }
        frontPtr++;
    }
    return result;
}
void run() {
  // this function behaves as `main()` for the 'run' command
  // you may sandbox in this function, but should not remove it
}
```
^1687767210975

##### **Attempt #3 (2023-26-06) â²ï¸ 00:08:00**

What did my third attempt for this problem look like? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
```cpp
#include <string>
#include <sstream>
#include <cctype>
std::string uncompress(std::string s) {
  // todo
  std::string result;
  std::stringstream ss;
  int groupLength {0};
  const char* it = &s[0];
  while(*it != '\0') {
    if(isalpha(*it)) {
      ss >> groupLength;
      result.append(groupLength, *it);
      ss.clear();
      groupLength = 0;
    }
    else {
      ss << *it;
    }
    it++;
  }
  return result;
}
void run() {
  // this function behaves as `main()` for the 'run' command
  // you may sandbox in this function, but should not remove it
}
```
^1687770561273

##### **Attempt #4 (2023-22-07) â²ï¸ 00:22:25**

Is the valid C++ code?
```cpp
std::substr()
```
 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
 No. The function `substr()` is a method of `std::string`.
^1690070505942

What is the easiest modern way in C++ to convert a `std::string` to an `int`? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
You can use the function `stoi()` from the standard library.
^1690070505950

How many parameters does `stdoi()` have? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
The function have three (1 being optional) parameters.
- First parameter is the string to convert
- Second parameter is an address of an integer to store the number of characters processed
- **Optional** The number base to use (Default is 10)
^1690070505958

What function should I use if I wish to convert a `char` to an `int`? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
Use the `atoi()` function.
^1690070505966

##### **Attempt #5 (2023-31-07) â²ï¸ 00:22:09**

What is the difference between using `stoi` and just using `stringstream()`? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- Both can get the same job done, `stringstream()` is only nicer when you just want to use a delimiter to fill in value to a container.
^1690838907864

What library is `stoi()` a part of? 
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
It is part of the `<cmath>` library.
^1690838907870

What is wrong with the following code?
```cpp
#include <string>
#include <algorithm>
#include <cctype>
#include <iostream>
using namespace std;
std::string uncompress(std::string s) {
    // todo
    std::string result = "";
    for(auto itF {s.begin()}; itF != s.end(); itF++) {
        auto itB = std::find_if_not(itF, s.end(), [](char ch){ return std::isdigit(ch); } );
        int repeatNum = std::stoi(std::string(itF,itB));
        while(repeatNum > 0) {
            result.push_back(*itB);
            repeatNum--;
        }
        itF = itB + 1;
    }
    return result;
}
```
#card  #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp
- Incrementing `itF` *before* **again** incrementing it from the forâ€“loop signature.
- When doing these LeetCode style assignments, but to use `while()`.
^1690838907875

#### Solution (Python)

#### Solution (JavaScript)


---

## ğŸ”œ Next Note(s):
- [[ğŸ”´ Academics/ğŸ“š Educational Resources/ğŸŒ Structy/1. Array and String/007. compress ğŸ‘¨ğŸ½â€ğŸ’»|007. compress ğŸ‘¨ğŸ½â€ğŸ’»]]

---
