---
title: 010. pair sumÂ ğŸ‘¨ğŸ½â€ğŸ’»
created: 2023-08-18 06:26
updated: 2023-11-18T02:44
authors:
  - Edmund Leibert III
tags:
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/structy
  - ğŸ”´-academic/ğŸ“š-educational-resource/source-format/internet
  - ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/structy/ğŸ”–/1-array-and-string/010-pair-sum-ğŸ§‘ğŸ½â€ğŸ’»
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/structy/ğŸ·ï¸/challenge
  - study-note
cards-deck: ğŸ”´ Academic::ğŸ“š Educational ResourceğŸŒ Structy::1. Array and String::010. pair sum ğŸ§‘ğŸ½â€ğŸ’»
---

#  ğŸŒ Structy

---

## ğŸ•¸ï¸ All Mention(s): 

---

## ğŸ”™ Previous Note(s):

---

## 1. Array and String

### **010. pair sumÂ ğŸ‘¨ğŸ½â€ğŸ’»**

#### ğŸ§­ Approach

#### ğŸ“½ï¸ Walkthrough

##### C++

##### Python

##### JavaScript

##### Java

#### ğŸ’¡Solution

> [!Note]+ Why is this section empty?
> For notes regarding solution(s), attempt(s), etc., refer to section below that is a _universal_ template for notes of such concern.


#### Solution (C++)

ï¹‡<br>
What is theÂ _optimal_Â solution to this problem? If there are multiple, list them out and compare.

#card  #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp

- **Official Structy Solution**: using a hashmap (unordered_map)

	```cpp
	#include <array> 
	#include <vector> 
	#include <unordered_map> 
	
	std::array<int, 2> pairSum(std::vector<int> numbers, int target) { 
		std::unordered_map<int, int> previousNums;
		for (int i = 0; i < numbers.size(); i += 1) {
			int complement = target - numbers[i];
			if (previousNums.count(complement) > 0) {
				return std::array<int, 2> {
					i, previousNums[complement] };
				}
			previousNums[numbers[i]] = i;
		}
	}
	```

	- n = size of vector
	- Time: O(n)
	- Space: O(n)

âŒ‚
<br>ï¹ˆ<br>^1694847548570



##### Attempt #2 :: ğŸ“† 2023-09-15 22:53 -07:00 :: âœ… :: \[Author(s): Edmund Leibert III\]

###### Performance

- â²ï¸ **Time**: `0:03:52`
- ğŸ§”ğŸ½â€â™‚ï¸ **Author(s)**:
	- Edmund Leibert III

###### Notes

ï¹‡<br>
```cpp
std::array<int, 2> pairSum(std::vector<int> numbers, int target) {
    unordered_map<int,int> numMap; // Elem, Pos
    // Iterate across and store for each elem its position
    auto it = numbers.begin();

    // Iterate again across and for each elem, find if its pair exists
    while(it != numbers.end()) {
        if(numMap.find(*it) == numMap.end()) {
            numMap[*it] = static_cast<int>( std::distance(numbers.begin(), it) );
        }

        // Check to see complement value for target already exsits
        if(numMap.find(target - *it) != numMap.end()) {
            if(numMap[target - *it] != static_cast<int>(std::distance(numbers.begin(), it))) {
                return {numMap[target - *it], static_cast<int>(std::distance(numbers.begin(), it))};
            }
        }

        it++;
    }


    return { };
}
```

What is happening in the return lines of this code? Does the brackets {} work for only std::array or could it work also if the return type defined in the signature of the function was a std::vector?

#card  #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp

In the return lines of this code, the `{}` brackets are being used to create an `std::array` with two elements. This is known as list initialization (or uniform initialization) in C++. The two elements of the array are the indices of the two numbers in the input vector that add up to the target value.

This syntax works not only for `std::array`, but also for many other types in C++, including `std::vector`. If you change the return type of the function to `std::vector<int>`, you can still use `{}` to create a vector. For example:

```cpp
return {num1, num2};
```

This will create a vector with two elements, `num1` and `num2`. However, keep in mind that while `std::array` has a fixed size, `std::vector` is dynamic and can change its size at runtime.

âŒ‚
<br>ï¹ˆ<br>^1694847548575




##### Attempt #1 :: ğŸ“† 2023-08-18 22:52 -07:00 :: âŒ :: \[Author(s): Edmund Leibert III\]

###### Performance

- â²ï¸ **Time**: `0:25:00`
- ğŸ§”ğŸ½â€â™‚ï¸ **Author(s)**:
	- Edmund Leibert III

###### Notes

ï¹‡<br>
What is the return type of `std::distance()`? 

#card  #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp

Should just be an `int`, but when using it in `std::array<int>{}`, need to `static_cast<int>()` the return type of `std::distance()`.

âŒ‚
<br>ï¹ˆ<br>^1694847548579



ï¹‡<br>
Is the following snippet of code valid? 

```cpp
if(numMap.find(*it) != numMap.end()) {
	numMap[*it] = static_cast<int>( std::distance(numbers.begin(), it) );
}
```

#card  #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp

- Yes, the following code snippet is valid, but *logically* wrong.
- If your **intention** is to insert `*it` if it is not currently in `numMap` then you want to change your condition in your `if` statement toâ€¦

```cpp
if(numMap.find(*it) == numMap.end) { // <- Means *it not found in numMap
// ...
}
```

âŒ‚
<br>ï¹ˆ<br>^1694847548584



#### Solution (Python)

#### Solution (JavaScript)

---

## ğŸ”œ Next Note(s):
- [[the-vault/ğŸ”´ Academics/ğŸ“š Educational Resources/ğŸŒ Structy/1. Array and String/011. pair product ğŸ‘¨ğŸ½â€ğŸ’»|011. pair product ğŸ‘¨ğŸ½â€ğŸ’»]]

---



