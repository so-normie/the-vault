---
title: 145. Binary Tree Postorder Traversal
authors:
  - Edmund Leibert III
created: 2023-11-18T09:24
updated: 2023-11-18T10:18
tags:
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/ğŸ”–/problems/145-binary-tree-postorder-traversal
  - ğŸ”´-academic/ğŸ“š-educational-resource/source-format/website
  - ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/problems/ğŸ·ï¸/premium/no
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/problems/ğŸ·ï¸/difficulty/easy
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/problems/ğŸ·ï¸/tag/topic/stack
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/problems/ğŸ·ï¸/tag/topic/tree
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/problems/ğŸ·ï¸/tag/topic/depth-first-search
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/problems/ğŸ·ï¸/tag/topic/binary-tree
  - study-note
cards-deck: ğŸ”´ Academic::ğŸ“š Educational Resource::LeetCode::Problems::145. Binary Tree Postorder Traversal
---

# 145. Binary Tree Postorder Traversal

---

> [!ABSTRACT]+
> Notes pertaining to [145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/).

---

> [!INFO]
> **Previous Notes**:
> 

---

## :TiNotes: Description

ï¹‡<br>
What is the `root` of a binary tree?

#card 

The root of a binary tree is the topmost node, from which all other nodes in the tree descend. Itâ€™s the only node in the tree that has no parent. 

In a binary tree, each node can have at most two children, referred to as the left child and the right child. The root node serves as the starting point for many operations on a binary tree.

âŒ‚
<br>ï¹ˆ<br>^1700328966697

ï¹‡<br>
What does post-order traversal mean?

#card 

**L**eft **R**ight **N**ode (i.e., LRN)

âŒ‚
<br>ï¹ˆ<br>^1700328966703

ï¹‡<br>
In normal, not reverse, order traversal of a binary tree, what node is visited earlier? The left or right node?

#card 

In binary tree _normal_ ordered traversal, the **left** node is visited earlier.

In binary tree _reverse_ ordered traversal, the **right** node is visited earlier.

âŒ‚
<br>ï¹ˆ<br>^1700328966710

When implementing an _iterative_ version of {1:depth-first search (DFS)}, one should use a {2:**stack**}.
^1700329089274

## :FarCircleQuestion: Guide

## :BoBxBookOpen: Editorial

## :RiFlaskLine: Solutions

## :RiHistoryLine: Submissions

### :SiCplusplus: C++

#### **Attempt #1** â€¢ ğŸ“† 2023-11-18 10:02 -08:00 â€¢ âŒ Failed â€¢ â±ï¸ 0:10:20 â€¢ \[Author(s): Edmund Leibert III\]

ï¹‡<br>
Is the following code a valid solution?

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
#include <vector>
#include <stack>

class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        std::vector<int> path;

        std::stack<TreeNode*> stack;
        TreeNode* lastNodeVisited = nullptr;

        while (!stack.empty() || root != nullptr) {
            if (root != nullptr) {
                stack.push(root);
                root = root->left;
            } else {
                TreeNode* peekNode = stack.top();
                // if right child exists and traversing node
                // from left child, then move right
                if (peekNode->right != nullptr && lastNodeVisited != peekNode->right) {
                    root = peekNode->right;
                } else {
                    path.push_back(peekNode->val);  // Corrected line
                    lastNodeVisited = stack.top();
                    stack.pop();
                }
            }
        }

        return path;
    }
};

```

#card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

Yes, the above code is both a correct _and_ efficient solution.

âŒ‚
<br>ï¹ˆ<br>^1700331424004

ï¹‡<br>
What is the pseudocode for a binary tree post-order traversal _iterative_ implementation?

#card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

**Post-order, LRN**

1. Recursively traverse the current node's left subtree.
2. Recursively traverse the current node's right subtree.
3. Visit the current node (in the figure: position blue).

Post-order traversal can be useful to get postfix expression of aÂ [binary expression tree](https://en.wikipedia.org/wiki/Binary_expression_tree "Binary expression tree"). [@TreeTraversal2023]

<pre><b>procedure</b> iterativePostorder(node)
    stack â† <b>empty stack</b>
    lastNodeVisited â† <b>null</b>
    <b>while</b> <b>not</b> stack.isEmpty() <b>or</b> node â‰  <b>null</b>
        <b>if</b> node â‰  <b>null</b>
            stack.push(node)
            node â† node.left
        <b>else</b>
            peekNode â† stack.peek()
            // if right child exists and traversing node
            // from left child, then move right
            <b>if</b> peekNode.right â‰  <b>null</b> <b>and</b> lastNodeVisited â‰  peekNode.right
                node â† peekNode.right
            <b>else</b>
                visit(peekNode)
                lastNodeVisited â† stack.pop()
</pre>

âŒ‚
<br>ï¹ˆ<br>^1700331424009

ï¹‡<br>
How do I insert an element into a stack in C++?

#card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

Call the `push()` method.

âŒ‚
<br>ï¹ˆ<br>^1700331424013

---

## :EiZoteroItem: Bibliography

---

> [!INFO]+ 
> **Next Note(s)**:
> 

---
