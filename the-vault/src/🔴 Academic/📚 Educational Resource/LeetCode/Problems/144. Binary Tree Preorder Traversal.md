---
title: 144. Binary Tree Preorder Traversal
authors:
  - Edmund Leibert III
created: 2023-11-14T12:54
updated: 2023-12-08T21:26
tags:
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/ğŸ”–/problems/144-binary-tree-preorder-traversal
  - ğŸ”´-academic/ğŸ“š-educational-resource/format/website
  - ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/ğŸ·ï¸/problems/premium/no
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/ğŸ·ï¸/problems/difficulty/easy
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/ğŸ·ï¸/problems/tag/topic/stack
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/ğŸ·ï¸/problems/tag/topic/tree
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/ğŸ·ï¸/problems/tag/topic/depth-first-search
  - ğŸ”´-academic/ğŸ“š-educational-resource/name/leetcode/ğŸ·ï¸/problems/tag/topic/binary-tree
  - study-note
cards-deck: ğŸ”´ Academic::ğŸ“š Educational Resource::LeetCode::Problems::144. Binary Tree Preorder Traversal
---

# 144. Binary Tree Preorder Traversal

---

> [!ABSTRACT]+
> 

---

> [!INFO]
> **Previous Notes**:
> 

---

## :TiNotes: Description

## :FarCircleQuestion: Guide

## :BoBxBookOpen: Editorial

## :RiFlaskLine: Solutions

## :RiHistoryLine: Submissions

### :SiCplusplus: C++

#### **Attempt #1** â€¢ ğŸ“† 2023-11-14 12:57 -08:00 â€¢ âŒ Failed â€¢ â±ï¸ 0:08:45 â€¢ \[Author(s): Edmund Leibert III\]

When implementing an _iterative_ version of {1:breadth-first search (DFS)}, one should use a {2:**stack**}. #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 
^1699995929679

When implementing an _iterative_ version of {1:depth-first search (BFS)}, one should use a {2:**queue**}. #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 
^1699995929686

ï¹‡<br>
Looking at the code below, what is the traversal order?

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

//  Preorder is NLR (DFS - Preorder)

#include <stack>

class Solution {
public:
    vector<int> mysteryTraversal(TreeNode* root) {
        std::stack<TreeNode*> q;
        std::vector<int> ans;

        if(root == nullptr) {
            return ans;
        }

        q.push(root);

        while(!q.empty()) {
            auto curr = q.top();
            q.pop();

            ans.push_back(curr->val);

            if (curr->right != nullptr) {
                q.push(curr->right);
            }
            if (curr->left != nullptr) {
                q.push(curr->left);
            }
        }

        return ans;
    }
};
```

#card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

The algorithm is using a pre-order traversal (i.e., NLR). 

âŒ‚
<br>ï¹ˆ<br>^1699995929692

ï¹‡<br>
What is the order of operations in a pre-order tree traversal (NLR)?

#card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

Visit the current node, recursively traverse the left subtree, then recursively traverse the right subtree. 

A parent node is processed before any of its child nodes.

âŒ‚
<br>ï¹ˆ<br>^1699996501331

ï¹‡<br>
What is the order of operations in a post-order tree traversal (LRN)?

#card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

Recursively traverse the left subtree, recursively traverse the right subtree, then visit the current node. 

This can be useful to get postfix expression of a binary expression tree.

âŒ‚
<br>ï¹ˆ<br>^1699996501337

ï¹‡<br>
What is the order of operations in an in-order tree traversal (LNR)?

#card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

Recursively traverse the left subtree, visit the current node, then recursively traverse the right subtree. 

In a binary search tree ordered such that in each node the key is greater than all keys in its left subtree and less than all keys in its right subtree, in-order traversal retrieves the keys in ascending sorted order.

âŒ‚
<br>ï¹ˆ<br>^1699996501343

ï¹‡<br>
What is the order of operations in a reverse pre-order tree traversal (NRL)?

#card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

Visit the current node, recursively traverse the right subtree, then recursively traverse the left subtree.

âŒ‚
<br>ï¹ˆ<br>^1699996501348

ï¹‡<br>
What is the order of operations in a reverse post-order tree traversal (RLN)?

#card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

Recursively traverse the right subtree, recursively traverse the left subtree, then visit the current node.

âŒ‚
<br>ï¹ˆ<br>^1699996501355

ï¹‡<br>
What is the order of operations in a reverse in-order tree traversal (RNL)?

#card #ğŸ”´-academic/ğŸ“š-educational-resource/discipline/computer-science/programming-language/cpp 

Recursively traverse the right subtree, visit the current node, then recursively traverse the left subtree.

âŒ‚
<br>ï¹ˆ<br>^1699996501362


ï¹‡<br>
What is the difference between iterative and recursive DFS traversal in terms of visiting left or right child first?

#card 

In anÂ **iterative DFS**Â using a stack, if we want to visit the left child before the right child, we push the right child onto the stack first. This is because a stack is a LIFO (Last In, First Out) structure, so the last node added will be the first one to be popped and processed.

On the other hand, in aÂ **recursive DFS**, we donâ€™t need to consider the LIFO nature of the stack. We can simply make the recursive call to the left child before the right child to visit the left child first. The call stack managed by the system during recursion will take care of preserving the order of visits.

âŒ‚
<br>ï¹ˆ<br>^1699996565101


ï¹‡<br>
What is the _recursive_ implementation of pre-order tree traversal?

#card 

<pre><b>procedure</b> preorder(node)
    <b>if</b> node = <b>null</b>
        <b>return</b>
    visit(node)
    preorder(node.left)
    preorder(node.right) 
</pre>

âŒ‚
<br>ï¹ˆ<br>^1699996684569


ï¹‡<br>
What is the _iterative_ implementation of pre-order tree traversal?

#card 

<pre><b>procedure</b> iterativePreorder(node)
    <b>if</b> node = <b>null</b>
        <b>return</b>
    stack â† <b>empty stack</b>
    stack.push(node)
    <b>while</b> <b>not</b> stack.isEmpty()
        node â† stack.pop()
        visit(node)
        // right child is pushed first so that left is processed first
        <b>if</b> node.right â‰  <b>null</b>
            stack.push(node.right)
        <b>if</b> node.left â‰  <b>null</b>
            stack.push(node.left)
</pre>

âŒ‚
<br>ï¹ˆ<br>^1699996723478





---

> [!INFO]+ 
> **Next Note(s)**:
> - 

---
