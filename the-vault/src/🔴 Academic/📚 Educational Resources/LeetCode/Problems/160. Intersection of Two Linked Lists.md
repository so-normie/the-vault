---
title: 160. Intersection of Two Linked Lists
authors:
  - Edmund Leibert III
created: 2023-11-19T01:16
updated: 2024-01-25T16:47
tags:
  - ğŸ”´-academic/ğŸ“š-educational-resources/name/leetcode/ğŸ”–/problems/160-intersection-of-two-linked-lists
  - ğŸ”´-academic/ğŸ“š-educational-resources/format/website
  - ğŸ”´-academic/ğŸ“š-educational-resources/discipline/computer-science
  - ğŸ”´-academic/ğŸ“š-educational-resources/name/leetcode/ğŸ·ï¸/problems/premium/no
  - ğŸ”´-academic/ğŸ“š-educational-resources/name/leetcode/ğŸ·ï¸/problems/tag/topic/hash-table
  - ğŸ”´-academic/ğŸ“š-educational-resources/name/leetcode/ğŸ·ï¸/problems/tag/topic/linked-list
  - ğŸ”´-academic/ğŸ“š-educational-resources/name/leetcode/ğŸ·ï¸/problems/tag/topic/two-pointers
  - study-note
cards-deck: ğŸ”´ Academic::ğŸ“š Educational Resource::LeetCode::Problems::160. Intersection of Two Linked Lists
---

# 160. Intersection of Two Linked Lists

---

> [!ABSTRACT]+
> Notes pertaining to [160. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/description/) [@160IntersectionTwo]

---

> [!INFO]
> **Previous Notes**:
> 

---

## :TiNotes: Description

## :FarCircleQuestion: Guide

## :BoBxBookOpen: Editorial

## :RiFlaskLine: Solutions

## :RiHistoryLine: Submissions

### :SiCplusplus: C++

#### **Attempt #1** â€¢ ğŸ“† 2023-11-19 01:22 -08:00 â€¢ âŒ Failed â€¢ â±ï¸ 0:07:20 â€¢ \[Author(s): Edmund Leibert III\]

ï¹‡<br>
Is the following code a valid solution?

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */


class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        auto ptrA = headA;
        auto ptrB = headB;
        while(ptrA != nullptr) {
            while(ptrB != nullptr) {
                if(ptrA == ptrB) {
                    return ptrA;
                }
                else {
                    ptrB = ptrB->next;
                }
            }
            ptrA = ptrA->next;
            ptrB = headB;
        }
        return ptrA;
    }
};
```

#card #ğŸ”´-academic/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

While the above solution is logically correct, it is **not** _efficient_. 

First and foremost, this solution uses a brute force approach where for each `ListNode` of â€œList Aâ€, it does a full iteration through â€œList Bâ€ to see if the `ListNode` of `ptrA` is the intersection. In consequence, this results in the following asymptotic complexityâ€¦

**Asymptotic Complexity**
- Time complexity: $\mathcal{O}(N*M)$ <br>
  For each of the $N$ nodes in â€œList Aâ€, we are traversing over each of the nodes in â€œList Bâ€. In the worst case, we wonâ€™t find a match, and so will need to do this until reaching the end of â€œList Bâ€, giving a worst-case time complexity of $\mathcal{O}(N \times M)$.
  
- Space complexity $\mathcal{O}(1)$ <br>
  We aren't allocating any additional data structures, so the amount of extra space used does not grow with the size of the input.

âŒ‚
<br>ï¹ˆ<br>^1700386550206


---

## :EiZoteroItem: Bibliography

---

> [!INFO]+ 
> **Next Note(s)**:
> 

---
