---
title: 163. Missing Ranges
authors:
  - Edmund Leibert III
created: 2023-11-20T06:20
updated: 2024-01-25T16:47
tags:
  - ğŸ”´-academic/ğŸ“š-educational-resources/name/leetcode/ğŸ”–/problems/163-missing-ranges
  - ğŸ”´-academic/ğŸ“š-educational-resources/format/website
  - ğŸ”´-academic/ğŸ“š-educational-resources/discipline/computer-science
  - ğŸ”´-academic/ğŸ“š-educational-resources/name/leetcode/ğŸ·ï¸/problems/premium/yes
  - ğŸ”´-academic/ğŸ“š-educational-resources/name/leetcode/ğŸ·ï¸/problems/difficulty/easy
  - ğŸ”´-academic/ğŸ“š-educational-resources/name/leetcode/ğŸ·ï¸/problems/tag/topic/array
  - study-note
cards-deck: ğŸ”´ Academic::ğŸ“š Educational Resource::LeetCode::Problems::163. Missing Ranges
---

# 163. Missing Ranges

---

> [!ABSTRACT]+
> Notes pertaining to [163. Missing Ranges - LeetCode](https://leetcode.com/problems/missing-ranges/description/).

---

> [!INFO]
> **Previous Notes**:
> 

---

## :TiNotes: Description

## :FarCircleQuestion: Guide

## :BoBxBookOpen: Editorial

## :RiFlaskLine: Solutions

## :RiHistoryLine: Submissions

### :SiCplusplus: C++

#### **Attempt #1** â€¢ ğŸ“† 2023-11-20 06:47 -08:00 â€¢ âŒ Failed â€¢ â±ï¸ 0:08:02 â€¢ \[Author(s): Edmund Leibert III\]

ï¹‡<br>
Take a look at the example code belowâ€¦

```cpp
// Need to do atelast one pass t: O(n)

/*
1. Definie out lower
2. Define our upper
pair low
pair up
*/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<vector<int>> findMissingRanges(vector<int>& nums, int lower, int upper) {
        vector<vector<int>> missing_ranges;

        // Define the lower values
        int low = lower;
        int up = upper;

        // Edge cases of nums being empty
        if (nums.size() == 0) {
            missing_ranges.push_back({lower, upper});
            return missing_ranges;
        }

        // Edge case check first, if we nums don't start at 0
        if(nums[0] != lower) {
            missing_ranges.push_back({lower,nums[0] - 1});
        }

        // General casre to check for all consectuive numbsers
        for(int i {0}; i < nums.size() - 1; i++) {
            if (nums[i + 1] - nums[i] <= 1) { // No gap in sequence
                continue;
            }
            missing_ranges.push_back({nums[i] + 1, nums[i + 1] - 1});
        }

        // Check for any missing numbers between the last element of nums and the upper bound.
        if (upper > nums[nums.size() - 1]) {
            missing_ranges.push_back({nums[nums.size() - 1] + 1, upper});
        }

        return missing_ranges;
    }
};
```

What is the difference between explicitly specifyingâ€¦

```cpp
vector<int>{2, 4}
```

â€¦and just doingâ€¦

```cpp
{4,2}
```

#card #ğŸ”´-academic/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

In C++, bothâ€¦
 
```cpp
vector<int>{2, 4}
```

â€¦andâ€¦ 

```cpp
{2, 4}
```

â€¦can be used to initialize a `vector<int>`. The difference lies in the context of usage.

1. <u>**Explicit declaration and initialization**</u>
   ```cpp
   vector<int>{2, 4}
   ```
   This is an explicit declaration and initialization. Youâ€™re specifying the type (`vector<int>`) and initializing it with the valuesâ€¦ 
   ```cpp
   {2, 4}
   ```
   This can be used in any context where a `vector<int>` is expected.

   ```cpp
   vector<int> v = vector<int>{2, 4};  // Explicit declaration and initialization
   ```

2. <u>**Simple initializer list**</u>
   ```cpp
   {2, 4}
   ``` 
   This is an initializer list. It can be used in contexts where the type can be inferred by the compiler. For example, when youâ€™re pushing back into a `vector<vector<int>>`, the compiler knows that the type must be `vector<int>`, so you can just provide the valuesâ€¦
	```cpp
	{2, 4}
	```


   ```cpp
    vector<vector<int>> vv;
    vv.push_back({2, 4});  // The compiler knows that {2, 4} must be a vector<int>
   ```

In your original codeâ€¦ 

```cpp
missing_ranges.push_back({lower, upper});
```
 
â€¦works because `missing_ranges` is a `vector<vector<int>>`, so the compiler knows thatâ€¦

```cpp
{lower, upper}
```

â€¦must be a `vector<int>`. If the type couldnâ€™t be inferred, you would need to use the explicit formâ€¦ 

```cpp
vector<int>{lower, upper}
```

So, to summarizeâ€¦ 

```cpp
{2, 4}
``` 

â€¦is a more concise way to writeâ€¦ 

```cpp
vector<int>{2, 4}
```

â€¦in contexts where the type can be inferred by the compiler. Otherwise, you need to use the explicit form. Both forms create a `vector<int>` with the same values.

âŒ‚
<br>ï¹ˆ<br>^1700582282577

ï¹‡<br>
What are the edge cases of this problem?

#card #ğŸ”´-academic/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

- <u>**Edge Case #1**</u><br>
  `nums.size()` is `0`. In this case, simply need to pushâ€¦.
  ```cpp
  {lower, upper}
  ```
  â€¦into `missing_ranges` and then `return` `missing_Ranges`. <br><br>
  
- Example codeâ€¦
  ```cpp
Â   if (nums.size() == 0) {
Â       missing_ranges.push_back({lower, upper});
Â       return missing_ranges;
Â   }
   ```

- <u>**Edge Case #2**</u><br>
  If we don't start withÂ `lower`Â as the first element of the array, we will need to includeÂ `[lower, num[0] - 1]`Â as a missing range as well.<br><br>
  Example codeâ€¦
  ```cpp
Â  Â if(nums[0] != lower) {
Â  Â     missing_ranges.push_back({lower,nums[0] - 1});
Â  Â }
   ```

- <u>**Edge Case #3**</u><br>
  Similarly, if we don't end withÂ `upper`Â as the last element of the array, we will need to includeÂ `[nums[n - 1] + 1, upper]`Â as a missing range as well whereÂ `n`Â is the length ofÂ `nums`.<br><br>
  Example codeâ€¦
  ```cpp
    if (upper > nums[nums.size() - 1]) {
       missing_ranges.push_back({nums[nums.size() - 1] + 1, upper});
    }
   ```

âŒ‚
<br>ï¹ˆ<br>^1700582282601

ï¹‡<br>
What is the general case for this problem?

#card #ğŸ”´-academic/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

```cpp
for(int i {0}; i < nums.size() - 1; i++) {
	if (nums[i + 1] - nums[i] <= 1) { // No gap in sequence
	    continue;
	}
	missing_ranges.push_back({nums[i] + 1, nums[i + 1] - 1});
}
```

âŒ‚
<br>ï¹ˆ<br>^1700582282610

ï¹‡<br>
Why does the loop in the general case component of this problem solution end atÂ `nums.size() - 1`?

For referenceâ€¦

```cpp
for(int i {0}; i < nums.size() - 1; i++) {
	if (nums[i + 1] - nums[i] <= 1) { // No gap in sequence
	    continue;
	}
	missing_ranges.push_back({nums[i] + 1, nums[i + 1] - 1});
}
```

#card #ğŸ”´-academic/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

The loop ends atÂ `nums.size() - 1`Â to avoid an out-of-bounds error on the lineÂ `nums[i + 1]`. IfÂ `i`Â were allowed to reachÂ `nums.size()`, thenÂ `nums[i + 1]`Â would be trying to access an element beyond the end of the array, which is not allowed in C++. This is a common pattern when dealing with pairs of elements in an array.

âŒ‚
<br>ï¹ˆ<br>^1700582282619


ï¹‡<br>
What must I remember to do when looping across a container, and desire to access not only the current element, but also the _next_ element?

#card #ğŸ”´-academic/ğŸ“š-educational-resources/discipline/computer-science/programming-language/cpp 

Need to remember to have the loop ends atÂ `nums.size() - 1`Â to avoid an out-of-bounds error on the lineÂ `nums[i + 1]`.

IfÂ `i`Â were allowed to reachÂ `nums.size()`, thenÂ `nums[i + 1]`Â would be trying to access an element beyond the end of the array, which is not allowed in C++. This is a common pattern when dealing with pairs of elements in an array.

âŒ‚
<br>ï¹ˆ<br>^1700582282627



---

## :EiZoteroItem: Bibliography

---

> [!INFO]+ 
> **Next Note(s)**:
> 

---
