---
title: 603. Consecutive Seats Available
created: 2023-09-12 01:33
updated: 2023-10-07 15:19
authors:
  - Edmund Leibert III
tags:
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-leetcode
  - ğŸ”´-academics/ğŸ“š-educational-resources/source-format/internet/website
  - ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-leetcode/ğŸ”–-bookmark/ğŸŒ-leetcode/problems/603-consecutive-seats-available
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-leetcode/ğŸ·ï¸-tag/problem/difficulty/easy
  - ğŸ”´-academics/ğŸ“š-educational-resources/name/ğŸŒ-leetcode/ğŸ·ï¸-tag/problem/tag/topic/database
  - study-note
cards-deck: ğŸ”´ Academics::ğŸ“š Educational Resources::ğŸŒ LeetCode::Problems::603. Consecutive Seats Available
---

# ğŸŒ Structy

---

## ğŸ•¸ï¸ All Mention(s): 

---

## ğŸ”™ Previous Note(s):

---

## 0. Introduction

### 603. Consecutive Seats Available

> [!info]+ Where can the problem be found?
> The problem can be found here:  [603. Consecutive Available Seats](https://leetcode.com/problems/consecutive-available-seats/)

#### Solution (SQL Server)

ï¹‡<br>
What is the _optimal_ solution to this problem? Provide analysis regarding what differentiates it to other approaches/solutions.

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/dbms/sql-server 


[**Approach**: Using self `JOIN` and `abs()`](https://leetcode.com/problems/consecutive-available-seats/editorial/)

```sql
/* Write your T-SQL query statement below */

SELECT 
    DISTINCT c1.seat_id
FROM 
    Cinema c1
JOIN 
    Cinema c2
ON 
    abs(c1.seat_id - c2.seat_id) = 1 AND
    c1.free = 1 AND
    c2.free = 1
ORDER BY c1.seat_id
;
```

âŒ‚
<br>ï¹ˆ<br>^1694510479534


##### Attempt #1 :: 2023-09-12 01:09 -07:00 :: âŒ :: \[Author(s): Edmund Leibert III\]

###### Performance

- â²ï¸ **Time**: `0:09:19`
- ğŸ§”ğŸ½â€â™‚ï¸ **Author(s)**:
	- Edmund Leibert III

###### Notes

ï¹‡<br>
What is a Self JOIN in SQL?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/dbms/sql-server 

A Self `JOIN` in SQL involves joining a table with itself. It is used when one wants to compare rows within the same table based on some condition, often represented using different aliases for the table being joined.

âŒ‚
<br>ï¹ˆ<br>^1694510479542


ï¹‡<br>
What factors affect the efficiency of a Self `JOIN`?

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/dbms/sql-server 


The factors include table size, indexes on joining columns, query complexity, the database engine, hardware specifications, and available alternatives like subqueries or window functions.

âŒ‚
<br>ï¹ˆ<br>^1694510479549

ï¹‡<br>
Give an example scenario where you might need to use a Self `JOIN`.

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/dbms/sql-server 


A common scenario for a Self `JOIN` is an `employees` table where each employee has a `manager_id` that refers back to the `id` in the same table. A Self `JOIN` can be used to find pairs of employees who share the same manager.

Suppose we have a table `employees` with the following columns:

- `id`: Unique identifier for each employee.
- `name`: Name of the employee.
- `manager_id`: The `id` of the manager for that employee.

Here's how the table might look:

```sql
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    manager_id INT
);

INSERT INTO employees (id, name, manager_id)
VALUES
    (1, 'Alice', NULL),  -- CEO, has no manager
    (2, 'Bob', 1),       -- Alice is the manager of Bob
    (3, 'Charlie', 1),   -- Alice is also the manager of Charlie
    (4, 'David', 2),     -- Bob is the manager of David
    (5, 'Eva', 2);       -- Bob is the manager of Eva
```

We can use a Self JOIN to find all pairs of employees who share the same manager:

```sql
SELECT
    e1.name AS Employee1,
    e2.name AS Employee2,
    m.name AS Manager
FROM
    employees e1
JOIN
    employees e2 ON e1.manager_id = e2.manager_id
JOIN
    employees m ON e1.manager_id = m.id
WHERE
    e1.id < e2.id;  -- To avoid duplicate pairs
```

In this query, `e1` and `e2` are aliases for two "copies" of the `employees` table. We join them on the `manager_id` column to find all pairs of employees (`e1`, `e2`) that have the same manager (`m`).

âŒ‚
<br>ï¹ˆ<br>^1694510479554

ï¹‡<br>
Is `LEFT OUTER JOIN` the same as `LEFT JOIN` in SQL Server?

#card-reverse #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/dbms/sql-server 


Yes, in SQL Server, `LEFT OUTER JOIN` and `LEFT JOIN` are functionally identical. The keyword `OUTER` is optional.

âŒ‚
<br>ï¹ˆ<br>^1694510901667


ï¹‡<br>
Is `RIGHT OUTER JOIN` the same as `RIGHT JOIN` in SQL Server?

#card-reverse #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/dbms/sql-server 


Yes, in SQL Server, `RIGHT OUTER JOIN` and `RIGHT JOIN` are functionally identical. The keyword `OUTER` is optional.

âŒ‚
<br>ï¹ˆ<br>^1694510901672


ï¹‡<br>
What does an `INNER JOIN` return in SQL Server when used as a self `JOIN`? 

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/dbms/sql-server 


An `INNER JOIN` in a self `JOIN` context returns only the rows that have a matching row on both sides of the join. Rows without a match are excluded.

âŒ‚
<br>ï¹ˆ<br>^1694510901677


ï¹‡<br>
What does a `LEFT OUTER JOIN` return in SQL Server when used as a self `JOIN`? 

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/dbms/sql-server 


A `LEFT OUTER JOIN` in a self `JOIN` context returns all rows from the left table and the matching rows from the right table. If there's no match, `NULL` values are returned for columns of the table that doesn't have a match.

âŒ‚
<br>ï¹ˆ<br>^1694510901682


ï¹‡<br>
What does a `FULL OUTER JOIN` return in SQL Server when used as a self `JOIN`? 

#card #ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/dbms/sql-server 

A `FULL OUTER JOIN` in a self `JOIN` context returns all rows when there is a match in either of the tables. Rows that don't have a match in the other table will have `NULL`s for every column of the table that doesn't have a match.

âŒ‚
<br>ï¹ˆ<br>^1694510901687

The result of a `JOIN` of two tables is theÂ {1:[Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product)}Â of these two tables.  
#ğŸ”´-academics/ğŸ“š-educational-resources/discipline/computer-science/dbms/sql-server
^1694511044506

ï¹‡<br>
What are the SQL window functions that can be used to solve the consecutive seat problem? 

#card

The SQL window functions `LEAD()` and `LAG()` can be used to solve the consecutive seat problem. They allow you to look at the next and previous rows, respectively, to check the value of the `free` column.

**Using Window Functions**

In this approach, you can use the `LEAD()` and `LAG()` window functions to look at the next and previous rows' `free` values. Then filter out the rows that have both the current and next (or previous) rows marked as free (`free = 1`).

```sql
-- Using Window Functions
WITH SeatWindow AS (
    SELECT 
        seat_id,
        free,
        LEAD(free) OVER (ORDER BY seat_id) AS next_free,
        LAG(free) OVER (ORDER BY seat_id) AS prev_free
    FROM 
        Cinema
)
SELECT 
    DISTINCT seat_id
FROM 
    SeatWindow
WHERE 
    (free = 1 AND next_free = 1) OR 
    (free = 1 AND prev_free = 1)
ORDER BY 
    seat_id;
```

âŒ‚
<br>ï¹ˆ<br>^1694511461632



ï¹‡<br>
How can you solve the consecutive seat problem in SQL using subqueries? 

#card

You can use subqueries with the `EXISTS` keyword to solve the consecutive seat problem. Within the subquery, you can filter seats that are 1 unit apart from each other in `seat_id` and check if they are free.

**Using Subqueries**

You can also solve this problem by using subqueries to identify the seats before and after each given seat and check their availability.

```sql
-- Using Subqueries
SELECT 
    DISTINCT c1.seat_id
FROM 
    Cinema c1
WHERE 
    EXISTS (
        SELECT 1
        FROM Cinema c2
        WHERE abs(c1.seat_id - c2.seat_id) = 1 AND c2.free = 1
    )
    AND c1.free = 1
ORDER BY 
    c1.seat_id;
```

âŒ‚
<br>ï¹ˆ<br>^1694511461637


---

## ğŸ”œ Next Note(s):
- 

---
